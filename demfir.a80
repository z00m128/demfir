; DEMFIR - DTP's EMulator FIles Runner
;
; This program can use some of ZX Spectum emulator files (.sna, .z80, .tap, .tzx)
; on real ZX Spectrum with IDE interface. It reads these files from ISO9660
; filesystem. Snapshots are directly loaded and runned, tap files are emulated
; like standard tape.
;
; Copyright (C) 2000-2007  Lubomir Blaha <tritol(at)trilogic(dot)cz>
; http://sourceforge.net/projects/demfir/
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;
; http://www.gnu.org/licenses/gpl.html
; Cesky neoficialni preklad http://www.gnu.cz/gpl-cz.html


		CPU	Z80UNDOC
		RELAXED	ON

		include "config.a80"

;DVERS	equ	"d0.7b"
DVERS	equ	"70206"

;------------------------------
; Definice konstant pro HADR

RDATA	equ	163
RPARAM	equ	167
RSECPOC	equ	171
RSEC		equ	175
RCYLL	equ	179
RCYLH	equ	183
RHEAD	equ	187
RCOM		equ	191
RSTAT	equ	191

CRESET	equ	$10
CRESETA	equ	$08
CREAD	equ	$20
CREAD10A	equ	$28
CWRITE	equ	$30
CWRITE10A	equ	$2A
CDIAG	equ	$90
CIDENT	equ	$EC
CIDENTA	equ	$A1
CATAPI	equ	$A0
CICHS	equ	$91

HKONST	equ	160

;------------------------------

;AS asi neumi OR v define, ojebavka...
	ifdef WITH_Z80
ANY_SNAP
	endif
	ifdef WITH_SNA
		ifndef ANY_SNAP
ANY_SNAP
		endif
	endif
	ifdef WITH_MFC
		ifndef ANY_SNAP
ANY_SNAP
		endif
	endif


;GLOBALNI KONSTANTY

;pocet "petivterin", po kolika se se nahodi pripadny screensaver
;(skutecne jednotky jsou 256 preruseni)
SSAVER	equ	120/5

;konstanty opakovani klaves
CON_REP	equ	6
CON_DEL	equ	36

;delka klavesoveho echa (ZXS 0, DG neco kolem 30)
CLICKLEN	equ	0

;timeouty pro ide device
IDETOUT	equ	0
IDETOUTS	equ	$3000

;konec RAM divIDE
DRAMTOP	equ	16384

;port pro strankovani RAM divIDE
RAMPORT	equ	227
;hodnota pro zapnuti CONMEM
CONMEM	equ	128
;hodnota pro zapnutit MAPRAM
MAPRAM	equ	64
;cislo stranky, ktera se pouziva jako MAPRAM (pro test)
MAPRPAGE	equ	3
;cislo stranky pro uchovani pameti a spol.
BACKPAGE	equ	1
;cislo stranky pro screensaver (zaloha vram, casem mozna i nacitany kod z disku pri bootovani)
SSPAGE	equ	2

;data v BACKPAGE

;kam v BACKPAGE ukladat VRAM + printbuffer (7168B)
BACKVRAM	equ	8192
BVLEN	equ	7168
;misto pro "emulaci" trdosu (adr. 15616, 256B)
;plni se pri resetu daty s TRDOSWRAP (259B)
TRDOS	equ	15616
;na TRDOS+256 by melo byt JP TOBASROM
;misto pro instrukci jp nn 3B, nutne pri spousteni snapu
SNARUN	equ	TRDOS+256+3
;misto pro ulozeni zasobniku pred startem mni menu
ORGSTACK	equ	TRDOS-2
;zasobnik pri vyvolani NMI (zatim cca 256B ale to je zbytecne moc)
BACKSTACK	equ	ORGSTACK

FREERAM1	equ	DRAMTOP-SNARUN-3

;nmi ma vlastni zasobnik (v printbufferu)
NMISTACK	equ	23552

;data pro jednotlive formaty snapu
;pri spousteni snapu se prepise zasobnik a data co se na nej ulozila pri vstupu
;do NMI menu ale to nemuze vadit

;delky .sna souboru
SNALEN1	equ	49179
SNALEN2	equ	131103
SNALEN3	equ	147487
SNAHDR	equ	27
;odtud zacina .sna
SNASTART	equ	DRAMTOP-SNAHDR

;zajimava data z .mfc
MFCHEAD	equ	55
;odtud zacina .mfc
MFCSTART	equ	DRAMTOP-MFCHEAD

;odtud zacina .z80
Z80HDR1	equ	30
Z80HDR2	equ	25
Z80START	equ	DRAMTOP-Z80HDR1-Z80HDR2

;kam docasne ukladat pridavna data od snapu (registry)
;mozna to presmazi NMISTACK, ale nemelo by vadit
SNATMP	equ	23296	;16384+6912

;docasna pamet pri hledani druhe casti (boot)
BOOTMEM	equ	49152

;s jakym IDE zarizenim pracovat
;0=master, 16=slave
DEVICE	equ	DRAMTOP-1

VALIDEV	equ	DEVICE-1
;0=zarizeni nebyla detekovana

;parametry zarizeni
	ifdef WITH_CHS
MAS_SECS	equ	VALIDEV-1		;pocet sektoru na stopu
MAS_HEDS	equ	MAS_SECS-1	;pocet hlav na povrch (valec nebo jak je to spravne cesky)
MAS_LBA	equ	MAS_HEDS-4	;velikost zarizeni v sektorech
	else
MAS_LBA	equ	VALIDEV-4
	endif
MAS_PRES	equ	MAS_LBA-1		;0-not present
MAS_ATAP	equ	MAS_PRES-1	;0-no lba, 1-atapi, 2-lba ide, 3-chs ide
MAS_NAME	equ	MAS_ATAP-32

	ifdef WITH_CHS
SLA_SECS	equ	MAS_NAME-1
SLA_HEDS	equ	SLA_SECS-1
SLA_LBA	equ	SLA_HEDS-4
	else
SLA_LBA	equ	MAS_NAME-4
	endif
SLA_PRES	equ	SLA_LBA-1
SLA_ATAP	equ	SLA_PRES-1
SLA_NAME	equ	SLA_ATAP-32

;velikost media a sektoru
MEDSIZE	equ	SLA_NAME-8
STATUS	equ	MEDSIZE-1
;0=unknown (no lba support)
;1=ready,
;2=not ready,
;3=medium error,
;4=device error

;jmeno media
DISKNAME	equ	STATUS-32
;aktualni pozice na mediu
LBADISK	equ	DISKNAME-3

;barva kurzoru (browser)
KURCOL	equ	LBADISK-1
;pozice kurzoru (browser)
POZICE	equ	KURCOL-1
;kde v indexu se nachazime
VYPIS	equ	POZICE-2
;kde v indexu zacina 2. sektor
ADR2SEC	equ	VYPIS-2
;kde v indexu je odkaz na posledni soubor
INDLAST	equ	ADR2SEC-2
;jsou nactena data aktualni
DISKACT	equ	INDLAST-1

;delka aktualniho adresare v sektorech (browser)
DIRLEN	equ	DISKACT-2
;aktulne nacteny sektor adr.
ACTSDIR	equ	DIRLEN-2

;tapka je aktivni
TAPACT	equ	ACTSDIR-1
;jmeno aktualni tapky (32 B)
TAPNAME	equ	TAPACT-32
;celkova delka tapky-pro index
;musi byt v tomto poradi (TAPLEN2 a za nim TAPLEN)
TAPLEN	equ	TAPNAME-4
;-pro vypis
TAPLEN2	equ	TAPLEN-4
;az sem??
;load-cursor
TAPCURS	equ	TAPLEN2-2
;pozice kurzoru (backup)
POZBAK	equ	TAPCURS-1
;kde v indexu (backup)
VYPBAK	equ	POZBAK-2

;pozice v cache (lze dopocitat, ale tohle je rychlejsi)
CACHEKUR	equ	VYPBAK-2
;aktualne nacteny sektor
CACHELBA	equ	CACHEKUR-3
;kolik B z nej je jeste k disp.
CACHEREM	equ	CACHELBA-2

;aktualni adresa tiskaci rutiny spolecne s instrukci JP
ACTPRINT	equ	CACHEREM-3
;aktualni adresa kam psat
;2. a 3. byte ukazatel do tab. adrvram (radek), prvni byte sloupec
PRINTPOZ	equ	ACTPRINT-3
;aktualni atribut
ACTATTR	equ	PRINTPOZ-1
;priznak inverze (0=ne, 255=ano)
ATTRINV	equ	ACTATTR-1

;kontrolni soucet ROM, pokud nesedi, inicializace
ROMCRC	equ	ATTRINV-2

;relativni LBA zacatek iso img.
ISOSTART	equ	ROMCRC-4

;misto pro data pri cteni klaves
REPPER	equ	ISOSTART-1
LASTKEY	equ	REPPER-1

;buffer pro input
INPBUFF	equ	LASTKEY-13		;3+2 a 11+2 pro POK, 7+2 pro LBA, 12+1 pro FileFind

;kam kreslit kurzor pri inkeys (0=nikam)
IKURPOS	equ	INPBUFF-2

;misto pro ukladani minule honoty pri blikani kurzorem
IKURINT	equ	IKURPOS-1

;misto pro registry AY
AYREGS	equ	IKURINT-16

;uchovani DE pri volani druhe ROM
TMPDE	equ	AYREGS-2

;0=DI, 255=EI
EIDI		equ	TMPDE-1

;0=pri stisku nmi bylo im2
JEIM2	equ	EIDI-1

;cislo aktivni stranky pri nmi
;0-7 +8 VRAM +16 ROM
;+64 pro kratky out +128=48K
ACTPAGE	equ	JEIM2-1

;PC pro 128K verzi SNA
SNAPC	equ	ACTPAGE-2
;cislo stranky pro 128K verzi SNA
SNAPAGE	equ	SNAPC-1

;promenne pro praci s casem (musi byt takhle za sebou)
SSTIMER	equ	SNAPAGE-1		;casovac screensaveru
INTCNT	equ	SSTIMER-2		;pocitadlo preruseni (jede porad dokola)

;priznak spravne druhe casti ("bootuje" se)
;0=neni, 2=je (2 kuli snadnemu vypisu)
GPART2	equ	INTCNT-1

;pocitadlo znaku pro hledani souboru
FFCNT	equ	GPART2-1

;docasne misto pro ulozeni cisla bloku tzx (registry dosly)
TZXBLKID	equ	FFCNT-1

;docasne misto pro pozici v bufferu
TZXBPOS	equ	TZXBLKID-2

;flag zda pri cteni klaves testovat shifty ci nikoliv
INPSHFT	equ	TZXBPOS-1

;priznak ze se ma ukladat (malo registru)
DOINGWR	equ	INPSHFT-1

;stack pri nacitani snapu
LOADSTACK	equ	DOINGWR

ENDVRS	equ	LOADSTACK-100

;misto pro ukladani sektoru ctenych z cdrom (2048B)
CACHE	equ	8192
;misto pro nacitani sektoru adresare - browser (4096B)
BUFFER	equ	CACHE+2048

;misto pro nacitani "hlavicek" TZX bloku (20B)
;je velice vyhodne mit ho na adrese s L=0 (nutne!!!)
TZXBUFF	equ	BUFFER+4096

;misto pro odkazy do adresare 2*293 polozek + 2 konc. znaky (588B) (4 konc. znaky ne?)
INDEX	equ	TZXBUFF+20

	ifdef WITH_POK
;24+1 zaznamu, odkazy do POKDATA
;defw adresa "traineru", 0 prazdno (konec)
POKCUR	equ	INDEX+588
POKTAB	equ	POKCUR+1
;POKTAB	equ	49152

;vyctena data o poke + aktualni platnost
POKDATA	equ	2*25+POKTAB
;defs 28 name
;defb status 0.bit=ask 1.bit=active 3.-5.bit cursor colour
;defb page (0 konec seznamu, +8 ignorovat stranku, or 64+16)
;defw adresa
;defb poke hodnota
;defb puvodni hodnota z .pok (0 neznamo)
;misto pro 24 zaznamu s jednou hodnotou nebo min zaznamu s vice hodnotami
POKEND	equ	35*24+POKDATA		;pocita s koncovymi znackami
	else
POKEND	equ	INDEX+588
	endif


FREERAM0	equ	ENDVRS-POKEND


;prvni cast, iso "driver" & zakladni rutiny
;bezi v EEPROM

		org	0
		di
		xor	a
		out	(RAMPORT),a
		jp	DORESETE
RST0ENDE

		org	8
;rst 8 - error
;s tim nic delat nebudem
A0008E	ld	hl,($5C5D)
A0008RE	push	hl
		ld	l,A0008RE
		jr	CONTEXE
RST8ENDE

		org	16
;rst 16 - tisk znaku
		exx
		call	ACTPRINT
		exx
		ret
RST16ENDE

		org	24
;rst 24 - tisk retezce za instrukci rst (PRINTSP)
		pop	hl
		call	PRINT128E
		jp	(hl)
RST24ENDE

;sem pri intu pri pristrankovanem DEMFIRu
;pocita s ld hl,xxx na dalsim byte!!!
		org	31
		defb	24			;jr 66 (ROMINTE)

;rst 32 - reset screensaveru
		ld	hl,SSAVER		;opcode se pouziva pro JR z predesle adresy!
		ld	a,l
		ld	(SSTIMER),a
		ret
RST32ENDE

		org	40
;rst 40 - volani druhe ROM (MAPRAM)
		ex	(sp),hl
		ld	(TMPDE),de
		ld	e,(hl)
		jr	RST40CNTE
RST40ENDE

		org	48
;rst 48 - strankovani RAM
;v A cislo RAM stranky
		or	CONMEM
		out	(RAMPORT),a
		ret
RST48ENDE

;preruseni je potreba
;zneuzijeme k pocitani casu...
		org	56

A0038E	defb	24
A0038RE	push	hl
		ld	l,A0038RE
CONTEXE	ld	h,0			;sice delsi, ale vejde se u RST8
		ex	(sp),hl
		jp	TOBASROM

ROMINTE	push	af
		push	hl
		ld	hl,INTCNT
		inc	(hl)
		jr	nz,INT1E
		inc	hl
		inc	(hl)
		inc	hl
		ld	a,(hl)
		or	a
		jr	z,INT1E
		dec	(hl)
INT1E	pop	hl
		pop	af
		ei
;		ret			;pokracuje dalsim byte!

;		org	85
;sem pri NMI pri pristrankovanem DEMFIRu
;a pouziva i depak LOGA (detekce adresy)
		ret				;musi byt na adrese 85!!!

;pokracovani volani druhe ROM
RST40CNTE	inc	hl
		ld	d,(hl)
		inc	hl
		ex	(sp),hl
		call	PREPDEE
OUTPAGEE	push	af
		ld	a,MAPRAM
		out	(RAMPORT),a
		pop	af
		ret
R40CENDE

		org	102

;obsluha NMI
;pri stisku nmi se prestrankuje az na adrese 103
;pri sifrovani tlacitka se skace na 102

		defb	24
;musi byt pristrankovana BACKPAGE
;vsechno pouzite uschovej
;(push af jeste z puvodni ROM)
		ld	(ORGSTACK),sp
		ld	sp,BACKSTACK
;stav preruseni (obsah R ztracen)
		ld	a,i
		push	af
		ld	a,255
		jp	pe,STOREINTE
		xor	a
STOREINTE	push	hl
		push	de
		push	bc
		push	ix
		push	iy
		exx
		push	hl
		push	de
		push	bc
		ex	af,af'		;v af` EIDI 
		push	af
;test modu preruseni
		ld	hl,15104		;59*256
		ld	b,0			;plni se 257B
		ld	a,h
		ld	i,a
		inc	a			;A=60
MAKEIM2E	ld	(hl),a
		inc	hl
		djnz	MAKEIM2E
		ld	(hl),a
;ld hl,xx
		defb	33
		xor	a
		ret
		ld	(15420),hl
;15420=60*256+60
		ei
		halt
		di
		im	1
;zaloha VRAM a printbufferu
		ld	hl,16384
		ld	de,BACKVRAM
		ld	bc,BVLEN
		ldir
		ld	b,a
		ld	sp,NMISTACK
;pro maximalni vyuziti pameti podminenym prekladem modifikovatelne casti az po
;vstupnich bodech pro LD/SA-BYTES
		jp	NMIBPGS

;cast strenkovani CONMEM/MAPRAM
PREPDEE	push	de
		ld	de,(TMPDE)
		jr	OUTPAGEE

;druha cast navratu (potrebujem v CONMEM i MAPRAM)
QUIT2E	out	(RAMPORT),a
		ld	sp,BACKSTACK-20	;10x push
;HL=BACKVRAM+6912 DE=23296 BC=0
		ld	b,(BVLEN-6912)/256
		ldir
		pop	af
		ex	af,af'
		pop	bc
		pop	de
		pop	hl
		exx
		pop	iy
		pop	ix
		pop	bc
		pop	de
		pop	hl
		pop	af
		ld	sp,(ORGSTACK)
		ld	i,a
;bylo povolene preruseni?
		jp	pe,EIROM2
		pop	af
;zakazane preruseni
		jp	TOBASROM
OVRLENDE

; ### VYPOCTY ###

;zvysi LBA o 1
INCLBA	ld	bc,1

;pricte k LBA cache cislo v reg. BC
ADDLBA	ld	hl,CACHELBA
ADDLBA2	push	de
		ld	a,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	e,(hl)
		ex	de,hl
		add	hl,bc
		adc	a,0
		ex	de,hl
		ld	(hl),e
		dec	hl
		ld	(hl),d
		dec	hl
		ld	(hl),a
		pop	de
		ret

;odecte od LBA (ukaz. v HL) cislo v reg. BC
SUBLBA2	push	de
		ld	a,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	e,(hl)
		ex	de,hl
		or	a
		sbc	hl,bc
		sbc	a,0
		ex	de,hl
		ld	(hl),e
		dec	hl
		ld	(hl),d
		dec	hl
		ld	(hl),a
		pop	de
		ret

;pricte k BCDE HLIX
ADD3232	add	ix,de
		ld	e,ixl
		ld	d,ixu
		adc	hl,bc
		ld	c,l
		ld	b,h
		ret

;spocita CRC bloku 128 B od zacatku stranky
CNTPGCRC	ld	hl,49152
		ld	bc,128
;spocita CRC bloku
;< HL - adresa zacatku paketu
;< BC - delka bloku
;> HL - spocitane crc
;meni BC,DE,HL,AF,AF'
;umi pocitat CRC podle ruznych
;polynomu, zalezi na konstantach
CNTCRC	ex	de,hl
		ld	hl,0
DCTCRC2	ld	a,h
		and	POLYMASK
		ex	af,af'
		add	hl,hl
		ld	a,(de)
		inc	de
		add	a,l
		ld	l,a
		ex	af,af'
		jr	z,DCTCRC3
		ld	a,h
		xor	POLYHI
		ld	h,a
		ld	a,l
		xor	POLYLO
		ld	l,a
DCTCRC3	dec	bc
		ld	a,b
		or	c
		jp	nz,DCTCRC2
		ret


; ### RUZNE RUTINKY ###
;XORnem cast stranky tak, aby byla mala pravdepodobnost shody s jinou strankou
XORPAGE	ld	de,49152
		ld	hl,DVRSN
		ld	b,5
XORPAGE2	ld	a,(de)
		xor	(hl)
		ld	(de),a
		inc	e
		inc	hl
		djnz	XORPAGE2
		ld	hl,INTCNT
		ld	a,(de)
		xor	(hl)
		ld	(de),a
		inc	e
		inc	hl
		ld	a,(de)
		xor	(hl)
		ld	(de),a
		ret

;vytiskne 32 mezer
SPACES	ld	b,32
SPACES1	ld	a,32
		rst	16
		djnz	SPACES1
		ret

;smaze celou RAM stranku (vyplni 0)
;v A je cislo stranky
CLRPG	rst	48
;to same bez strankovani
CLRPG2	xor	a
		ld	hl,8192
		ld	b,h
		ld	c,l		;byte navic, ale to nas nebere...
		jr	FILLBYTE


;odhad barvy borderu podle atr.
;v levem hornim rohu obrazovky
GUESBORD	ld	a,(22528)
		rra
		rra
		rra
		and	7
		out	(254),a
		ret

;"inicializace" obrazu
SCRINIT	call	CLS
		out	(254),a		;v A zustala 0
		call	ATRIB
		call	PRINTINI
		jp	LOGO

;smazani obrazovky
CLS		push	hl
		push	de
		ld	hl,16384
		ld	bc,6911
		xor	a
		call	FILLBYTE
		pop	de
		pop	hl
		ret

;vyplneni atributu obs. reg. A
ATRIB	ld	hl,22528
		ld	bc,767
;vyplneni BC+1 bajtu od HL obsahem A
;meni DE
FILLBYTE	ld	(hl),a
		ld	d,h
		ld	e,l
		inc	de
		ldir
		ret


;tiskaci podprogramy
PRINT128E	ld	a,(hl)
		and	127
		rst	16
		bit	7,(hl)
		inc	hl
		jr	z,PRINT128E
		ret

PRINTB	ld	a,(hl)
		cp	32
		call	c,PRB1
		bit	7,a
		call	nz,PRB1
		rst	16
		inc	hl
		djnz	PRINTB
		ret
PRB1		ld	a,'?'
		ret


;test symbol shiftu (nc=stisteno)
SSHIFT	ld	a,127			;stisk SS
		in	a,(254)
		rra
		rra
		ret


;endian prohazeni
;HL adresa
;B kolik bytu
;MENI: A
PROHOD	push	hl
		push	bc
		rrc	b
PROHOD1
		ld	a,(hl)
		inc	hl
		ld	c,(hl)
		dec	hl
		ld	(hl),c
		inc	hl
		ld	(hl),a
		inc	hl
		djnz	PROHOD1
		pop	bc
		pop	hl
		ret


;vytiskne delku v HLDE
;v A znak pro tisk nevyznamnych nul, 0=netisknout
;tiskne jednotku (B/K/M), v c vraci desetiny
PRSIZE	ld	bc,'B'*256+0
		ex	af,af'
		ld	a,e
		or	d
		jr	z,PRLEN
		call	NAKM
		ld	a,e
		or	a
		ld	b,'K'
		jr	z,PRLEN
		call	NAKM
		ld	b,'M'
PRLEN	push	bc
		ex	af,af'
		ld	c,a
		call	PRINTHL2
		pop	bc
		ld	a,' '
		rst	16
		ld	a,b
		rst	16
;		ld	a,c
;		or	a
;		ret	z
;		ld	a,'0'
;		add	a,c
;		rst	16
		ret

;prevede cislo v DEHL na vyssi
;jednotky (kila nebo mega)
;>HL vysledek
;  C desetiny
NAKM		xor	a
;/1024 (/256 /4)
		ld	l,h
		ld	h,e
		ld	e,d
		ld	d,a
		srl	e
		rr	h
		rr	l
		jr	nc,DES1
		add	a,2
DES1		srl	e
		rr	h
		rr	l
		jr	nc,DES2
		add	a,5
DES2		ld	c,a
		ret


;precte dva za sebou jdouci sektory adresare do bufferu
;na LBADISK adresa prvniho sec.
;pokud je adresar dlouhy jen jeden sektor, nactou se nejake
;blbosti do druheho, ale to nevadi
GETISO1	ld	hl,BUFFER
		ld	de,LBADISK
		ld	a,2
		jp	RDWRSEC

;vytvori index sektoru
;v HL adresa prvniho souboru
GETISO2	push	hl
		ld	hl,INDEX
		ld	bc,588-1
		xor	a
		call	FILLBYTE
		ld	de,INDEX+2
		pop	hl
		call	GETIND
		ld	(ADR2SEC),de
		ld	hl,(DIRLEN)
;adresar ma jen jeden sektor?
		dec	hl
		ld	a,l
		or	h
		ret	z
		ld	hl,BUFFER+2048
;		jp	GETIND
;sem nic nepridavat!

;vytvori index jednoho sektoru
;v DE ukazatel na index
;v HL ukazatel na sektor
GETIND	ld	bc,2048
		push	hl
		add	hl,bc
		ld	b,h
		ld	c,l
		pop	hl
GETINDSM	ld	a,(hl)
		or	a
		jr	z,GETINDEND
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
		push	bc
		ld	c,a
		ld	b,0
		add	hl,bc
;tohle tu asi nemusi byt (iso9660 dir sektor konci vzdycky nulou?), ale pro jistotu
		pop	bc
		or	a
		sbc	hl,bc
		add	hl,bc
		jr	c,GETINDSM
GETINDEND	dec	de				;predesla polozka (tj. posledni)
		dec	de
		ld	(INDLAST),de
		ret


;podprogam pro cteni klaves (ceka) s autorepeatem
;potrebuje povolene preruseni hodnota v A a D
INKEYSRAW	xor	a
		defb	33				;preskoceni dalsi instrukce
INKEYS	ld	a,255
		ld	(INPSHFT),a
INKEYSX	ld	hl,(IKURPOS)
		ld	a,h
		or	l
		jr	z,INKEYS4
		ld	a,(IKURINT)
		ld	c,a
		and	16
		ld	b,a
		ld	a,(INTCNT)
		ld	c,a
		and	16
		xor	b
		jr	z,INKEYS4
		ld	a,c
		ld	(IKURINT),a
		ld	b,8
INKUR	ld	a,(hl)
		xor	1
		ld	(hl),a
		inc	h
		djnz	INKUR
INKEYS4	halt
		ld	a,(REPPER)
		dec	a
		jr	z,DOBA
		ld	(REPPER),a
DOBA		call	KEYSCAN
		jr	nz,INKEYS3
		ld	a,e
		inc	a
		jr	z,INKEYS3
		ld	a,(INPSHFT)		;bez testu shiftu?
		or	a
		jr	z,INKEYSY
		ld	a,d
		ld	hl,KEYSSSTAB
		cp	$18				;SS
		jr	z,INKEYS2
		ld	hl,KEYSCSTAB
		cp	$27				;CS
		jr	z,INKEYS2
INKEYSY	ld	hl,KEYSTAB
INKEYS2	ld	d,0
		add	hl,de
		ld	a,(hl)
		or	a
		jr	z,INKEYS3
		ld	hl,LASTKEY
		cp	(hl)
		jr	z,MINANO
		ld	(hl),a
		jr	INKEYSPOL

INKEYS3	ld	a,CON_DEL
		ld	(REPPER),a
		xor	a
		ld	(LASTKEY),a
;jestlipak poustet screensaver (musi se postarat o zalohu VRAM)
	ifdef WITH_SS
		ld	a,(SSTIMER)
		or	a
		call	z,DEMFSS
	endif
		jr	INKEYSX

MINANO	ld	d,a
		ld	a,(REPPER)
		dec	a
		jr	nz,INKEYSX
		ld	a,CON_REP
		ld	(REPPER),a
		ld	a,d
INKEYSPOL	push	af
		call	CLICK
	ifdef WITH_SS
		rst	32
	endif
		pop	af
		ld	d,a
		ret


;program z ROM (adr $28E) - cteni klavesnice
KEYSCAN	ld	l,$2F
		ld	de,$FFFF
		ld	bc,$FEFE
KEYLINE	in	a,(c)
		cpl
		and	$1F
		jr	z,KEYDONE
		ld	h,a
		ld	a,l
KEY3KEYS	inc	d
		ret	nz
KEYBITS	sub	8
		srl	h
		jr	nc,KEYBITS
		ld	d,e
		ld	e,a
		jr	nz,KEY3KEYS
KEYDONE	dec	l
		rlc	b
		jr	c,KEYLINE
		ld	a,d
		inc	a
		ret	z
		cp	$28
		ret	z
		cp	$19
		ret	z
		ld	a,e
		ld	e,d
		ld	d,a
		cp	$18
		ret

;beep
BEEPE	push	hl
		push	af			;potrebujem zachovat flagy kuli snadnemu volani
		ld	de,256
		ld	hl,384
		call	BEEPER
		pop	af
		pop	hl
		ret

;klavesove echo
CLICK	ld	de,CLICKLEN
		ld	hl,$C8
;program z ROM (adr $3B5) - generovani tonu (beep)
BEEPER	di
		push	ix
		ld	a,l
		srl	l
		srl	l
		cpl
		and	3
		ld	c,a
		ld	b,0
		ld	ix,BEIX3
		add	ix,bc
		ld	a,8;+1		;fixme - debug
BEIX3	nop
BEIX2	nop
BEIX1	nop
BEIX0	inc	b
		inc	c
BEHLLP	dec	c
		jr	nz,BEHLLP
		ld	c,$3f
		dec	b
		jp	nz,BEHLLP
		xor	$10
		out	(254),a
		ld	b,h
		ld	c,a
		bit	4,a
		jr	nz,BEAGAIN
		ld	a,d
		or	e
		jr	z,BEEND
		ld	a,c
		ld	c,l
		dec	de
		jp	(ix)

BEAGAIN	ld	c,l
		inc	c
		jp	(ix)

BEEND	pop	ix
		ei
		ret


;vytiskne parametry souboru
;(je tady aby se porad nestrankovaly ROMky)
FILEPARM	rst	24
		defb	22,23,128
		ld	l,(ix+10)
		ld	h,(ix+11)
		ld	e,(ix+12)
		ld	d,(ix+13)
		ld	a,' '
		call	PRSIZE
		rst	24
		defb	23,15,128
		ld	l,(ix+18)
		ld	h,0
		ld	bc,1900
		add	hl,bc
		call	PRINTHL
		ld	a,'-'
		rst	16
		ld	l,(ix+19)
		call	PRINTL2
		ld	a,'-'
		rst	16
		ld	l,(ix+20)
		call	PRINTL2
		ld	a,' '
		rst	16
		ld	l,(ix+21)
		call	PRINTL2
		ld	a,':'
		rst	16
		ld	l,(ix+22)
		jp	PRINTL2
		
;precte cislo v textove podobe z adresy DE
;vysledek v HLIY, na (DE) prvni neplatny znak
;vynecha mezery na zacatku
;a konci ma prvnim neplatnem znaku
ATOLH	ld	a,(de)
		inc	de
		cp	' '
		jr	z,ATOLH
		dec	de
		ld	hl,0
		push	hl
		pop	iy
ATOLH2	ld	a,(de)
		sub	'0'
		ret	c
		cp	10
		jr	c,ATOLH3
		or	32				;na mala pismena
		sub	'a'-'9'-1
		ret	c
		cp	16
		ret	nc
;v A je 0-15
ATOLH3	inc	de
;nasob HLIY 16x
		add	iy,iy
		adc	hl,hl
		add	iy,iy
		adc	hl,hl
		add	iy,iy
		adc	hl,hl
		add	iy,iy
		adc	hl,hl
;pricti soucasne cislo
		add	a,iyl
		ld	iyl,a
		jr	ATOLH2

;vstup jedne radky textu
;DE - ukazatel na buffer zacinajici a ukonceny bytem 160 (inv. mezera)
;IY - tiskova pozice (x*256+y)
;HL - pozice kurzoru v bufferu (adresa) 0=najdi konec
;buffer musi mit alespon 2 platne znaky (4B)
;volajici kod musi po navratu ulozit 0 na IKURPOS (2B)
;Ovladani:
;CS+1 - exit (navrat s carry)
;CS+2 - clear entry
;CS+3 - nic (zatim volne)
;CS+4 - insert (vlozi mezeru za kurzor)
;CS+5 - left
;CS+6 - home
;CS+7 - end
;CS+8 - right
;CS+9 - delete
;CS+0 - backspace
INPUT	ld	de,INPBUFF
INPUTDE	ld	a,h
		or	l
		jr	nz,INPUT3			;nehledej konec
		ld	l,e
		ld	h,d
		call	INPUTFEND
		inc	hl
;najdem posledni platny znak
INPUT2	dec	hl
		ld	a,(hl)
		bit	7,a
		jr	nz,INPUT3
		cp	' '
		jr	z,INPUT2
INPUT3	ld	c,l
		ld	b,h				;pozice kurzoru
;vypisem co mame
INPUT4	ld	l,e
		ld	h,d
		ld	a,22
		rst	16
		ld	a,iyu
		rst	16
		ld	a,iyl
		rst	16
		ld	a,' '
		rst	16
INPUTSM1	inc	hl
		bit	7,(hl)
		jr	nz,INPUT5
		ld	a,(hl)
		rst	16
		jr	INPUTSM1
		
;spocitame kam kreslit input kurzor
INPUT5	ld	a,iyu
		add	a,a
		ld	hl,ADRVRAM
		add	a,l
		ld	l,a
		jr	nc,INPUT6
		inc	h
INPUT6	push	hl
		ld	l,c
		ld	h,b
		or	a
		sbc	hl,de			;od kurzoru zacatek bufferu
		ld	a,l				;vzdy min jak 256
		pop	hl
		add	a,(hl)			;posun v radku nepretece
		inc	hl
		ld	h,(hl)
		add	a,iyl			;posun v radku nepretece
		ld	l,a
		ld	(IKURPOS),hl
INPUTSM2	push	de
		push	bc
		call	INKEYS
		pop	bc
		pop	de
		ld	l,c
		ld	h,b
		cp	32
		jr	nc,INPCHAR
		sub	5				;CS+4
		jr	nz,INCTRL0
;insert
		call	INPUTFEND
		ld	a,(hl)
		cp	' '
		jr	nz,INCTRL2		;neni kam vkladat
INPINS	scf					;dec hl
		sbc	hl,bc
		add	hl,bc
		jr	z,INPINS2
		ld	a,(hl)
		inc	hl
		ld	(hl),a
		dec	hl
		jr	INPINS

INPINS2	inc	hl
		ld	(hl),32
		jr	INPUT4

INCTRL0	dec	a				;CS+2
		jr	nz,INCTRL1
;vymazani bufferu (vyplneni mezerami)
		ld	l,e
		ld	h,d
		ld	c,l
		ld	b,h
		inc	hl
		ld	a,32
INPCLR	bit	7,(hl)
		jr	nz,INPUT4
		ld	(hl),a
		inc	hl
		jr	INPCLR

INCTRL1	dec	a				;CS+1 (edit)
		scf
		ret	z
		dec	a				;CS+5
		jr	nz,INCTRL2
;kurzor vlevo
		bit	7,(hl)
		jr	nz,INPUTSM2
		dec	hl
BYTESAVE1	jr	INPUT3

INCTRL2	dec	a				;CS+8
		jr	nz,INCTRL3
;kurzor vpravo
		inc	hl
		bit	7,(hl)
		jr	nz,INPUTSM2
		jr	BYTESAVE1

INCTRL3	dec	a				;CS+6
		jr	nz,INCTRL4
;home
		ld	c,e
		ld	b,d
		jp	INPUT4

INCTRL4	dec	a				;CS+7
		jr	nz,INCTRL5
;end
		call	INPUTFEND
		jr	BYTESAVE1

INCTRL5	dec	a				;CS+0
		jr	nz,INCTRL6
;backspace
		bit	7,(hl)
		jr	nz,INPUTSM2		;na zacatku nepracuje
		dec	bc
		jr	INPDEL

INCTRL6	or	a				;set nc
		dec	a				;ENTER
		ret	z
		dec	a				;CS+9
		jr	nz,INPUTSM2
;delete
		inc	hl
		bit	7,(hl)
		jr	nz,INPUTSM2		;na konci nepracuje
INPDEL	inc	hl
		bit	7,(hl)
		jr	nz,INPDEL2
		ld	a,(hl)
		dec	hl
		ld	(hl),a
		inc	hl
		jr	INPDEL

INPDEL2	dec	hl
		ld	(hl),32
		jp	INPUT4

;obyc. znak
INPCHAR	inc	hl
		bit	7,(hl)
		jp	nz,INPUTSM2
		ld	(hl),a
		jr	BYTESAVE1


BEF_SVBE
;odchyceni save (jen pokracuje zpet v ZX ROM)
		org	$4C6
GAP_SVBE	equ	$-BEF_SVBE

		ld	hl,$1F80
;z puvodni ROM
		push	hl
		ld	hl,$4C6+3
		ex	(sp),hl
		jp	TOBASROM
;konec odchyceni save

;najde konec input bufferu (ukazuje na posledni platny znak)
INPUTFEND	inc	hl
		bit	7,(hl)
		jr	z,INPUTFEND
		dec	hl
		ret

;test "signatury" image
;NZ-neni to on
CHECKBOOT	ld	hl,BOOTMEM+PAGESIGN
		ld	bc,5
		ld	de,DVRSN
		jr	MEMCMP

;porovnani signatury PDV
;Z-nalezena
CHECKPVD	ld	bc,6
		ld	de,ISOSIGN
;porovna dva useky v pameti
;HL-prvni, DE-druhy, BC-delka
;Z-rovnaji se
MEMCMP	ld	a,(de)
		cpi
		ret	nz
		inc	de
		jp	pe,MEMCMP
		ret


;fixme! spousta mista tu je




BEF_LDBE
;odchyceni load (jen pokracuje zpet v ZX ROM)
		org	$562
GAP_LDBE	equ	$-BEF_LDBE

		in	a,($FE)
;z puvodni ROM
		push	hl
		ld	hl,$562+2
		push	hl
		ex   (sp),hl
		jp	TOBASROM
;konec odchyceni load


;pocka par preruseni
NOSIFR	halt
NOSIFR2	halt
		halt
		halt
		halt
		ret

;vytiskne LBA zacatku image a LBA max. adresovatelneho sekt.
LBAS		ld	hl,(ISOSTART+2)
		call	PRNT12HX
		ld	hl,(ISOSTART)
		call	PRNT16HX
LBAS2	ld	a,'/'
		rst	16
		ld	h,(ix+37)
		ld	l,(ix+36)
		call	PRNT12HX
		ld	h,(ix+35)
		ld	l,(ix+34)
		jp	PRNT16HX


;sem to skace z obou stranek z NMI
NMIBPGS	xor	a
		rst	48
		ld	a,b
		ld	(JEIM2),a
		ex	af,af'
		ld	(EIDI),a
;umlci AY a ulozi si hodnoty
		ld	c,253
		ld	hl,AYREGS
		ld	de,16
AYREAD	ld	b,255
		out	(c),d
		in	a,(c)
		ld	(hl),a
		ld	b,191
		xor	a
		out	(c),a
		inc	hl
		inc	d
		dec	e
		jr	nz,AYREAD
;detekce modu (48/128) a detekce stranek
;pozmenime data pameti abysme je poznali
		call	XORPAGE
		call	CNTPGCRC
		ex	de,hl
;ROM + kratky out
		ld	bc,16+64
TSTPAGES	ld	a,c
		out	(253),a
		push	de
		push	bc
		call	CNTPGCRC
		pop	bc
		pop	de
		or	a
		sbc	hl,de
		jr	nz,TSTPAGES2
;CRC se rovnaji, vyhodnotime
;pokud je jiz nastaveno "48K mode", konec
		bit	7,b
		jr	nz,TSTPAGES3
;pokud se uz nejaka stranka nasla -> "48K mode"
		bit	4,b
		ld	b,c
		jr	z,TSTPAGES2
		set	7,b
TSTPAGES2	inc	c
		bit	3,c
		jr	z,TSTPAGES
TSTPAGES3	ld	a,b
		ld	(ACTPAGE),a
		and	127
		out	(253),a
;vratime puvodni data
		call	XORPAGE
;zakaz preruseni (mohlo byt povoleno nekde dal a sem se to vzdycky vraci)
NMIMENU	di
;vynulovani promennych
		ld	a,36
		ld	(REPPER),a
		call	SCRINIT
		rst	24				;call PRINTSP
		defb 19,1,22,0,0,16,6	;yellow
		defb "Int:"
		defb	16,4,'I','M'+128
		ld	a,(JEIM2)
		or	a
		ld	a,'1'
		jr	nz,INFO1
		inc	a
INFO1	rst	16
		ld	a,'/'
		rst	16
		ld	a,(EIDI)
		or	a
		ld	a,'D'
		jr	z,INFO2
		inc	a
INFO2	rst	16
		rst	24				;call PRINTSP
		defb 'I',16,6			;yellow
		defb " Mode:"
		defb	16,4+128			;green
		ld	a,(ACTPAGE)
		ld	b,a
		bit	7,a
		ld	hl,128
		ld	c,0
		jr	z,INFO3
		ld	l,48
		ld	b,c				;vynulujem cislo stranky, nema smysl
INFO3	call	PRINTHL2
		rst	24				;call PRINTSP
		defb 'K',16,6			;yellow
		defb " Page:"
		defb	16,4+128			;green
		ld	a,b
		and	7
		add	a,'0'
		rst	16
		rst	24				;call PRINTSP
		defb 16,6
		defb " VR:"
		defb 16,4+128
		ld	a,b
		and	8
		ld	a,'0'
		jr	z,INFO4
		inc	a
INFO4	rst	16
		rst	24				;call PRINTSP
		defb 13,16,5			;formaty souboru
	ifdef WITH_Z80
		defb "Z80 "
	endif
	ifdef WITH_SNA
		defb "SNA "
	endif
	ifdef WITH_MFC
		defb "MFC "
	endif
	ifdef WITH_SCR
		defb "SCR "
	endif
	ifdef WITH_TXT
		defb "TXT "
	endif
	ifdef WITH_POK
		defb "POK "
	endif
		defb	13				;moduly a ficury
	ifdef WITH_CHS
		defb "CHS "
	endif
	ifdef WITH_WDC
		defb "WDC "
	endif
	ifdef ROM_2A_3
		defb	"+3R "
	endif
	ifdef WITH_MTF
		defb	"MTF "
	endif
	ifdef WITH_SS
		defb "SSv "
	endif
		defb ' '+128

		ld	a,(VALIDEV)
		or	a
		jp	nz,INITD2
		rst	24				;call PRINTSP
		defb	22,3,26,16,2
DVRSN	defb	DVERS
		defb	22,17,0,18,1
		defb	" Detecting devices, please wait "
		defb	18,128
		xor	a
		ld	ix,MAS_NAME
		call	DETECT
		ld	a,16
		ld	(VALIDEV),a
		ld	ix,SLA_NAME
		call	DETECT
;tesne po detekci nektera zarizeni neodpovidaji na cteni
		ei
		call	NOSIFR
		di
		rst	24				;call PRINTSP
		defb	22,17,128
		call	SPACES
		xor	a
NEWMED2	ld	(DEVICE),a
NEWMED	ld	hl,0
		ld	(ISOSTART+2),hl
		ld	(ISOSTART),hl
NEWMED3	xor	a
		ld	(DISKNAME),a
		ld	(TAPACT),a
		ld	(DISKACT),a
;smaz radek "medium"
		rst	24				;call PRINTSP
		defb	22,17,128
		call	SPACES
INITD2	rst	24				;call PRINTSP
		defb	16,6
		defb	22,15,0
		defb	20,1,"D",20
		defb	0
		defb	"evice:",' '+128
		ld	a,(DEVICE)
		or	HKONST
		out	(RHEAD),a
;active master/slave
		and	16
		ld	ix,MAS_NAME
		ld	hl,MASTER
		jr	z,INITD3
		ld	ix,SLA_NAME
		ld	hl,SLAVE
INITD3	call	PRINT128E
		call	GETREADY
		ld	a,6
		rst	16
		ld	a,(STATUS)
		add	a,a
		ld	e,a
		ld	d,0
		ld	hl,STATTBL
	ifdef WITH_CHS
		ld	a,(ix+32)
		cp	3
		jr	nz,INITD3X
		ld	hl,STATTBL2
INITD3X
	endif
		add	hl,de
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
		call	PRINT128E
		ld	a,13
		rst	16
		push	ix
		pop	hl
		ld	b,32
		call	PRINTB
		rst	24				;call PRINTSP
		defb	16,6
		defb	13,20,1,"M",20,0
		defb	"edium: "
		defb	16,3+128
		ld	a,(TAPACT)
		or	a
		jr	z,MEDNOTP
		ld	hl,(TAPLEN2)
		ld	de,(TAPLEN2+2)
		xor	a
		call	PRSIZE
		rst	24				;call PRINTSP
		defb	13,16,5+128
		ld	hl,TAPNAME
		jp	SPOLMED2

MEDNOTP	call	GETPARAM
		call	GETPVD
		ld	a,(DISKNAME)
		or	a
		jr	nz,JEMEDIUM
		rst	24				;call PRINTSP
		defb	6,16,2
		defb	"<no ISO 9660>  "
		defb	13+128
		call	SPACES
		jr	SPOLMED

JEMEDIUM
;velikost media (vzdy 2048x)
		ld	hl,(MEDSIZE+2)
		ld	de,(MEDSIZE)
;nasob 256x 8x (dohromady 2048)
		ld	d,e
		ld	e,h
		ld	h,l
		ld	l,0
		add	hl,hl
		ex	de,hl
		adc	hl,hl
		ex	de,hl
		add	hl,hl
		ex	de,hl
		adc	hl,hl
		ex	de,hl
		add	hl,hl
		ex	de,hl
		adc	hl,hl
		ex	de,hl
		xor	a
		call	PRSIZE
		rst	24				;call PRINTSP
		defb	22,17,16,16,4+128
		ld	a,(MEDSIZE+7)
		cp	3
		jr	c,EMULMED
;cdrom
		rst	24				;call PRINTSP
		defb	16,4
		defb	"<real CD-ROM> ",' '+128
		jr	SPOLMED3

EMULMED	call	LBAS
SPOLMED3	rst	24				;call PRINTSP
		defb	16,5,13+128
		ld	hl,DISKNAME
SPOLMED2	ld	b,32
		call	PRINTB
		ld	a,(GPART2)
		or	a
		call	z,DASBOOT			;pokusime se nacist druhou cast
SPOLMED	ld	a,16
		rst	16
		ld	a,(GPART2)
		add	a,2				;red or green
		rst	16
		rst	24
		defb 22,3,26
		defb	DVERS
		defb	22,23,0,16,6
		defb	20,1,"R",20,0
		defb	"es"
		defb	20,1,"I",20,0
		defb	"nit"
		defb	20,1,"Q",20,0
		defb	"uit"
		defb	20,1,"F",20,0
		defb	"ind"
		defb	20,1,"S",20,0
		defb	"ec"
;eject removed
;		defb	20,1,"E",20,0
;		defb	"jct"
		defb 20,1,"V",20,0
		defb "ram"
		defb	20,1,"P",20,0
		defb	"gng"
	ifdef WITH_POK
		defb 20,1,"C",20,0
		defb	"ht"
	endif
		defb	20,1
		defb	"Ent"
		defb	20,128

		ei
NMIKEYS	call	INKEYSRAW
		ld	hl,NMIPROG
NMIK4	ld	a,(hl)
		or	a
		jr	z,NMIKEYS
		cp	d
		inc	hl
		jr	z,NMIK3
		inc	hl
		inc	hl
		jr	NMIK4

NMIK3	ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
		jp	(hl)


;obsluha klaves nmimenu

;eject removed
;vystreleni media :)
;EJMED	ld	a,(ix+32)
;		or	a
;		jr	z,NOMED
;		dec	a
;		jr	nz,NOENT
;		ld	hl,EJECT
;		call	ATAPICOM
;		jp	NEWMED

NOMED	ld	hl,15*32+22528+16
		ld	bc,13
FLASH	push	hl
		push	bc
		ld	a,2+64+128
		call	FILLBYTE
		call	BEEPE
		ld	b,100
FLASH2	halt
		djnz	FLASH2
		pop	bc
		pop	hl
		ld	a,2+64
		call	FILLBYTE
		jp	NMIKEYS

;znovunacteni media
MEDIUM	ld	a,(ix+33)
		or	a
		jr	z,NOMED
		jp	NEWMED

;find image
FINDIMG	ld	hl,FINDISO
		jr	SPOLISO

;zadani sectoru kde hledat iso
SECTIMP	ld	hl,INPUTSEC
SPOLISO	ld	a,(ix+33)
		or	a
		jr	z,NOMED
		ld	a,(MEDSIZE+7)
		cp	3
		jr	nc,NOENT
		ld	de,NEWMED3
		push	de
		jp	(hl)

;prochazni media
ENTBROWS	ld	a,(GPART2)
		or	a
		jr	nz,ENTBROWS2
;zablikame verzi (neni pritomna druha cast)
NOTPT2	ld	hl,3*32+22528+26
		ld	bc,4
		jr	FLASH

;prochazni media pro mapram cast
ENTBROWS2	ld	a,(DISKNAME)
		or	a
		jr	z,NOENT
		rst	40				;call mapram
		defw	CDBROWS
		jp	NMIMENU

NOENT	ld	hl,17*32+22528+16
		ld	bc,12
		jr	FLASH

	ifdef WITH_POK
;prechod do poke manageru
ENTPOKMAN	ld	a,(GPART2)
		or	a
		jr	z,NOTPT2
		rst	40
		defw	POKEMAN
		jp	NMIMENU
	endif

;change device (master/slave)
CHDEV
		ld	a,(DEVICE)
		xor	16
		jp	NEWMED2

;init demfir (detect devices)
DEMINT	xor	a
		ld	(VALIDEV),a
		jp	NMIMENU

;navrat z nmi
QUIT		ld	hl,AYREGS			;obnoveni registru AY
;naboucha do AY data z (HL)
		ld	c,253
		ld	de,16
QUITAY	ld	a,(hl)
		ld	b,255
		out	(c),d
		ld	b,191
		out	(c),a
		inc	hl
		inc	d
		dec	e
		jr	nz,QUITAY
;vrat puvodni stranku a zvolenou VRAM (ne pro mod 48K)
		ld	a,(ACTPAGE)
		bit	7,a
		jr	nz,TSTIM2
		out	(253),a
TSTIM2	
;vratime puvodni obsah VRAM
		call	POPSCR
		di
;bylo im2?
		ld	a,(JEIM2)
		or	a
		jr	nz,NEIM2
		im	2
NEIM2	ld	a,BACKPAGE
		jp	QUIT2E			;pokracujem casti ktera je stejna v obou ROM
		
;reset
RESET	call	SSHIFT			;pri SS reset i s vymazanim RAM & spol
		jr	c,RESET2
;poskodime CRC
		ld	a,(ROMCRC)
		cpl
		ld	(ROMCRC),a
RESET2	rst	0


;vyber VRAM
VRAMSEL	call	POPSCR			;nejdrive vratime puvodni obsah
		ld	a,(ACTPAGE)
VRAMSEL1	ld	c,a
		and	127
		out	(253),a
		ld	b,25				;25*4 preruseni (2 sec)
VRAMSEL2	call	NOSIFR2
		ld	a,254			;klavesa "V"
		in	a,(254)
		bit	4,a
		ld	a,c
		jr	nz,VRAMSEL3
		xor	8
		jr	VRAMSEL1

VRAMSEL3	djnz	VRAMSEL2
		ld	(ACTPAGE),a
		and	127-8			;vzdy 1. VRAM
		out	(253),a
	ifdef WITH_SS
		rst	32
	endif
		jp	NMIMENU

;zakazani 128k strankovani
DIPAGING	ld	a,48+64			;kratky out
		out	(253),a
		ld	a,128
		ld	(ACTPAGE),a
		jp	NMIMENU


;podpurne rutiny

;obnoveni puvodni obrazovky
POPSCR	di
		ld	a,BACKPAGE
		rst	48
		ld	hl,BACKVRAM
		ld	de,16384
		ld	bc,6912
		ldir
		xor	a
		rst	48
		call	GUESBORD
		ei
		jp	NOSIFR


; ### OBSLUHA CACHE ###
;inicializace cache
;HL ukazatel na LBA zacatku
CAINIT	ld	de,CACHELBA
		ld	bc,3
		ldir
CAINIT2	ld	hl,0
		ld	(CACHEREM),hl
		ld	hl,CACHE
		jr	CASPUKR

;nastavi priznak "zapisuji", je teba ho nakonec
;shodit (zavolat CAFLUSH), jinak to bude zapisovat porad!!!
CAWRITE	ld	a,255
		ld	(DOINGWR),a
;precte/ulozi BC bajtu od posledniho mista na/z adresu/y DE
;CARRY error
;DE ukazuje za nacteny blok (vzdycky???)
CAREAD	ld	hl,(CACHEREM)
		ex	af,af'
		ld	a,l
		or	h
		jr	z,CARD2
		or	a
		sbc	hl,bc
		jr	z,CARD1
		jr	c,CARD1
;jen prenes data
		ld	(CACHEREM),hl
		ld	hl,(CACHEKUR)
		ex	af,af'
		or	a
		jr	z,NOWR1
		ex	de,hl
NOWR1	ldir
		or	a
		jr	z,CASPUKR
		ex	de,hl
CASPUKR	ld	(CACHEKUR),hl
		or	a
		ret

CARD1	add	hl,bc
;zbytek z cache prenes na pozadovane misto
		push	bc
		push	hl
		ld	b,h
		ld	c,l
		ld	hl,(CACHEKUR)
		ex	af,af'
		or	a
		jr	z,NOWR2
		ex	de,hl
NOWR2	ldir
		or	a
		jr	z,NOWR3
		ex	de,hl
;ulozeni dat v cache
		push	de
		ld	de,CACHELBA
		ld	hl,CACHE
		call	RDWR1SEC
		pop	de
;FIXME! test carry (bacha na zasobnik)
;posun se na dalsi sektor
		call	INCLBA
;neni potreba ukladat pozici
NOWR3	pop	hl
		pop	bc
;v BC celkova pozadovana delka
;v HL kolik uz se preneslo ze zbytku cache (obracene kuli skoku)
CARD2	push	de
		ld	e,l
		ld	d,h
		ld	l,c
		ld	h,b
;odecteni prenesene casti
		or	a
		sbc	hl,de
;konec jestli prenesl vsechno
		pop	de
		jp	z,CAINIT2
;zjisti pocet sektoru (/2048)
		ld	a,h
		srl	a
		srl	a
		srl	a
		jr	z,CARD3
;budem cist vice sektoru naraz
;v DE kam nacist
;v HL zbyvajici pozad. delka
		ex	de,hl
		push	de
		push	af
		ld	de,CACHELBA
		call	RDWRSEC
;tady by to chtelo test CARRY
		pop	af
		pop	de
		ld	c,a
		ld	b,0
		push	hl
		call	ADDLBA
		pop	hl
		ld	a,c
		add	a,a
		add	a,a
		add	a,a
		ld	b,a
		ld	c,0
;v BC je prave nactena delka
;v DE zbyvajici pozad. delka
;v HL adresa kde zkoncilo cteni?
		ex	de,hl
		or	a
		sbc	hl,bc
		jp	z,CAINIT2
;v HL kolik jeste prenest
;v DE kam
CARD3	push	de
		push	hl
		ld	hl,CACHE
		push	hl
;pro zapis pouze prenest data
		ld	a,(DOINGWR)
		or	a
		jr	nz,DOWR1
		ld	de,CACHELBA
		call	RDWR1SEC
DOWR1	pop	hl
		pop	bc
		pop	de
;DE kam, BC kolik, v HL odkud
		ret	c				;pro WR je to OK
		ld	a,(DOINGWR)
		or	a
		jr	z,NOWR5
		ex	de,hl
NOWR5	ldir
		or	a
		jr	z,NOWR6
		ex	de,hl
;uloz ukazatele
NOWR6	ld	(CACHEKUR),hl
		ld	b,h
		ld	c,l
		ld	hl,CACHE+2048
		or	a
		sbc	hl,bc
		ld	(CACHEREM),hl
;posun se na dalsi sektor (ne pro write)
		or	a
		call	z,INCLBA
		or	a				;NC
		ret

;ulozeni sektoru cache na disk
;FIXME! chtelo by to neplatna data (zbytek cache) vyplnit 0
;pri upravach NEZAPOMENOUT nulovat (DOINGWR)
CAFLUSH	ld	hl,(CACHEREM)
		ld	a,l
		or	h
		ld	de,CACHELBA
		ld	hl,CACHE
		call	nz,RDWR1SEC	;pokud v cache nic neni tak neukladej
;test navratove hodnoty asi nema moc cenu, jenom to pripadne ohlasit
;shozeni priznaku zapisu
		xor	a
		ld	(DOINGWR),a
		ret


;preskoci DEBC bajtu od posledniho mista
;zatim vyuzivano pouze pro TZX
;fixme! prepsat na jednorazove a ne volanim CASEEK
CALSEEK	push	de
		call	CASEEK
		pop	de
		ret	c
		ld	a,e
		or	d
		ret	z
		dec	de
;nejde seek po 64K, takze "per partes" :(
		ld	bc,32768
		push	de
		push	bc
		call	CASEEK
		ret	c
		pop	bc
		pop	de
		jr	CALSEEK

;preskoci BC bajtu od posledniho mista
CASEEK	ld	hl,(CACHEREM)
		ld	a,l
		or	h
		jr	z,CASK2
		or	a
		sbc	hl,bc
		jr	z,CASK1
		jr	c,CASK1
		ld	(CACHEREM),hl
		ld	hl,(CACHEKUR)
		add	hl,bc
		ld	(CACHEKUR),hl
		or	a
		ret

CASK1	add	hl,bc
;v BC celkova pozadovana delka
;v HL kolik uz se preskocilo ze zbytku cache (obracene kuli skoku)
CASK2	ld	e,l
		ld	d,h
		ld	l,c
		ld	h,b
;odecteni prenesene casti
		or	a
		sbc	hl,de
;konec jestli preskocil vsechno
		jp	z,CAINIT2
;zjisti pocet sektoru (/2048)
		ld	a,h
		srl	a
		srl	a
		srl	a
		jr	z,CASK3
;budem skakat vic sektoru naraz
;v HL zbyvajici pozad. delka
		ex	de,hl
		ld	c,a
		ld	b,0
		call	ADDLBA
		ld	a,c
		add	a,a
		add	a,a
		add	a,a
		ld	b,a
		ld	c,0
;v BC je prave preskocena delka
;v DE zbyvajici pozad. delka
		ex	de,hl
		or	a
		sbc	hl,bc
		jp	z,CAINIT2
;v HL kolik jeste preskocit
CASK3	push	hl
		ld	hl,CACHE
		ld	de,CACHELBA
		call	RDWR1SEC
		pop	bc
;BC kolik
		ret	c
		ld	hl,CACHE
		add	hl,bc
		ld	(CACHEKUR),hl
		ld	hl,2048
		or	a
		sbc	hl,bc
		ld	(CACHEREM),hl
;posun se na dalsi sektor
		call	INCLBA
		or	a
		ret


;zjisti stav zarizeni
GETREADY	ld	a,(ix+33)
		or	a
		call	nz,GETRDY2
		ld	(STATUS),a
		dec	a
		ret	z
;chyba, zrus medium
		xor	a
		ld	(DISKNAME),a
		ret

GETRDY2	ld	a,(ix+32)
		or	a
		ret	z
;a=0 - no lba
		dec	a
		ld	a,1
		ret	nz
;a=1 or a=2 - ready ide lba or chs device

;pokus o odliseni hw resetu od
;vymeny media; selze pri vymene
;media s resetem
		in	a,(RSTAT)
		push	af
		ld	hl,TUREADY
		call	ATAPICOM
		pop	de
;test chyby by "zabral" i pokud
;neni medium, coz nechceme...
		ld	a,1
;a=1 - ready
		ret	nc
		ld	a,c
		rrca
		rrca
		rrca
		rrca
		and	%00001111
		cp	2
		ret	z
;a=2 - not ready
		cp	3
		ret	z
;a=3 - medium error
		cp	6
		ld	a,4
		ret	nz
;a=4 - device error
;vymenene medium, znovu nacti
;ale pouze pokud to nebyl reset
		ld	a,d
		or	a
		ld	a,1
;a=1 - ready
		ret	z
		xor	a
		ld	(DISKNAME),a
		ld	(DISKACT),a
		inc	a
;a=1 - ready
		ret

;sem to skace po resetu v CONROM
DORESETE	ld	sp,NMISTACK	;je celkem jedno kde
		call SCRINIT
;48K BASIC se strankovanim 128K
	ifdef ROM_2A_3
;i pro +2A/+3
		ld	bc,8189
		ld	a,4
		out	(c),a
	endif
		ld	a,16+64
		out	(253),a
;test jestli je mapram ci nikoliv
		ld	hl,16383
		ld	a,MAPRPAGE
		out	(RAMPORT),a
		ld	a,(hl)
		cpl
		ld	(hl),a
		cp	(hl)
		cpl
		ld	(hl),a
		jr	z,DOCRCE
;kdyz nesedi (write protect), bezime v mapram
HALTUJ	xor	a
		out	(RAMPORT),a
		rst	24
		defb	22,20,0,16,2,18,1,19,1
		defb	" Since v0.6 can't run in MAPRAM "
		defb	13
		defb	"     Flash image to EEPROM      "
		defb	13
		defb	"      and turn MAPRAM off      ",' '+128
HALTUJ2	jr	HALTUJ2		;konecna

;spocitame CRC CONROM
;kdyz nesedi, bud nova verze ROM nebo spatna data v RAM
DOCRCE	xor	a
		out	(RAMPORT),a
		ld	hl,0
		ld	bc,8192		;cela ROM
		call	CNTCRC
		ex	de,hl
		ld	hl,(ROMCRC)
		or	a
		sbc	hl,de
		jr	z,CRCOKE
		push	de
		call	CLRPG2
		pop	hl
		ld	(ROMCRC),hl
CRCOKE
;init screenseveru
	ifdef WITH_SS
		rst	32
	endif
		ld	a,BACKPAGE
		out	(RAMPORT),a
	ifdef STDRST
		ld	hl,1
	else
;workaround pro ISOROM a podobne hruzy
		xor	a
		ld	de,$FFFF
		ld	hl,$11CB
	endif
		jp	ROMJPHL



	ifdef WITH_CHS
;deleni BAZE
;Input: BC:HL = Dividend, D = Divisor, A = 0
;Output: BC:HL = Quotient, A = Remainder
DIV_32_8	xor	a
		ld	e,32
DEL_CHS1	add	hl,hl		; unroll 32 times
		rl	c			; ...
		rl	b			; ...
		rla				; ...
		cp	d			; ...
		jr	c,DEL_CHS2	; ...
		sub	d			; ...
		inc	l			; ...
DEL_CHS2	dec	e
		jr	nz,DEL_CHS1
		ret
;konec deleni BAZE
	endif	;WITH_CHS



	ifdef WITH_SS
;screen saver
;POZOR!!! diky povolenemu preruseni se prepisuje INTCNT ale v pristrankovane strance! (tj. se zalohou VRAM)
DEMFSS	di
		ld	a,SSPAGE
		rst	48
		ld	hl,16384
		ld	de,8192
		ld	bc,6912
		ldir
		call	SCRINIT2
		ld	a,16
		rst	16
		ld	a,7
		ld	b,8
DEMFSS3	rst	24
		defb "  Hello. I'm your Screen Saver.",13,13
		defb "    Press any key to exit me.",13+128
		djnz	DEMFSS3
		ei
		ld	de,DEMFSSTBE
DEMFSS2	ld	a,(de)
		inc	a
		jr	nz,DEMFSS4
		ld	de,DEMFSSTB
		ld	a,r
		and	7
		ld	l,a
		add	a,a
		add	a,l
		ld	l,a
		ld	h,0
		add	hl,hl
		add	hl,hl
		add	hl,hl
		add	hl,hl
		add	hl,hl
		ld	bc,22528
		add	hl,bc
DEMFSS4	ld	a,(de)
		push	de
		ld	e,l
		ld	d,h
		inc	de
		ld	bc,3*32-1
		ld	(hl),a
		push	hl
		ldir
		pop	hl
		pop	de
		inc	de
		halt
		halt
		halt
		halt
		xor	a
		in	a,(254)
		cpl
		and	31
		jr	z,DEMFSS2
		di
		ld	hl,8192
		ld	de,16384
		ld	bc,6912
		ldir
DEMFSS5	xor	a
		in	a,(254)
		cpl
		and	31
		jr	nz,DEMFSS5
		xor	a
		rst	48
		rst	32	;nastaveni citace
		ei
		ret

DEMFSSTB	defb	0,1,1+64,2,2+64,3,3+64,4,4+64,5,5+64,6,6+64,7
		defb	7+64,7+64,7+64,7+64,7+64,7+64
		defb	7,6+64,6,5+64,5,4+64,4,3+64,3,2+64,2,1+64,1,0
DEMFSSTBE	defb	255

SSLEN	equ	$-DEMFSS
	endif

;detekce zarizeni
TSTATAPI	ld	a,CIDENTA
		out	(RCOM),a
		ld	hl,BUFFER
		ld	bc,RDATA
		call	IDE_DTRDS
		ret	c
		inir
		inir
;test konce operace
		call	IDE_DRRDS
		ret	c
		ld	a,1
		ld	(ix+32),a
		jp	DETECT2

DETECT	ld	(DEVICE),a
		or	HKONST
		out	(RHEAD),a
;active master/slave
;inicializace prostoru
		push	ix
		pop	de
		ld	hl,NOTDEV
		ld	bc,34
		ldir
		ld	a,CIDENT
		out	(RCOM),a
		ld	hl,BUFFER
		ld	bc,RDATA
		call	IDE_DTRDS
		jr	c,TSTATAPI
		inir
		inir
;test konce operace
		call	IDE_DRRDS
		ret	c
	ifdef WITH_WDC
;at je to LBA nebo CHS zarizeni, zkusime jestli ma nahozenou translaci
;(WD Caviar bez toho nezijou ani v LBA modu (pekny sracky))
;preskocit na zadost uzivatele?
		call	SSHIFT
		jr	nc,CHSOK
;je platna geometrie? (mozna by se mel testovat i validity bit,
;ale snad to nebude potreba)
		ld	hl,BUFFER+108
		ld	a,(hl)
		inc	hl
		or	(hl)		;109
		inc	hl
		or	(hl)		;110
		inc	hl
		inc	hl
		or	(hl)		;112
		jr	nz,CHSOK
;inicializace default CHS prepoctu
CHSINIT	ld	a,(BUFFER+6)		;heads
		dec	a				;device chce maxheads (=actheads-1)
		and	15				;pro jistotu kdyby nahodou byla 0
		ld	b,a
		ld	a,(DEVICE)
		or	HKONST
		or	b
		ld	b,a
		ld	a,CICHS
		ex	af,af'
		ld	a,(BUFFER+12)		;sectors
		ld	de,0
		ld	c,e
		call	IDEOUT
		jr	c,DETECT2
;test konce operace
		call	IDE_DRRDS
		jr	c,DETECT2
		in	a,(RSTAT)
		rra
		jr	c,DETECT2
;povedlo se nastavit default CHS prepocet, nechame detekce a oznamime
		push	ix
		pop	de
		ld	bc,17
		ld	hl,CHSSUCC
		ldir
		ld	c,e
		ld	b,d
		ld	hl,(BUFFER+2)
		call	STOR16DC
		ld	a,'/'
		ld	(bc),a
		inc	bc
		ld	hl,(BUFFER+6)
		call	STOR6DC
		ld	a,'/'
		ld	(bc),a
		inc	bc
		ld	hl,(BUFFER+12)
		jp	STOR6DC
		
CHSOK
	endif ;WITH_WDC
;podporuje ide zarizeni LBA?
		ld	a,(BUFFER+99)
		bit	1,a
	ifdef WITH_CHS
		jr	z,DETECT3
	else
		jr	z,DETECT2
	endif
;podporuje, berem
		call	SSHIFT			;SS=fixed size
		ld	a,2
		ld	hl,(BUFFER+120)
		ld	de,(BUFFER+122)
		jr	c,DETECTSPL
		ld	de,4095			;268435455 = 2^28-1
		ld	hl,65535
DETECTSPL
		ld	(ix+32),a
;uloz si velikost disku
		ld	(ix+34),l
		ld	(ix+35),h
		ld	(ix+36),e
		ld	(ix+37),d
DETECT2
		push	ix
		pop	de
		ld	hl,BUFFER+54
		ld	bc,32
		call	PROHOD
		ldir
		inc	de
		ld	a,255
		ld	(de),a
		ret

	ifdef WITH_CHS
DETECT3
;je to CHS zarizeni
;spolehnem se na spocitanou geometri a velikost
		ld	bc,(BUFFER+112)		;current sectors
		ld	a,(BUFFER+110)			;current heads
		ld	b,a
		ld	hl,(BUFFER+114)
		ld	de,(BUFFER+116)
		call	SSHIFT				;SS=fixed size + def. CHS
		jr	c,DETECT4
		ld	bc,(BUFFER+12)			;default sectors
		ld	a,(BUFFER+6)			;default heads
		ld	b,a
		ld	de,251				;16514063 = (16383*16*63)-1
		ld	hl,64527
DETECT4	ld	(ix+38),b
		ld	(ix+39),c
		ld	a,3
		jr	DETECTSPL
	endif	; WITH_CHS


;zjisti velikost sektoru
GETPARAM	call	RDYCHNG
		ret	nz
;nacti velikost media
		ld	hl,MEDSIZE
		ld	bc,7
		xor	a
		call	FILLBYTE
		ld	a,(ix+32)
		dec	a
		jr	z,GETPRMA
;pro ide naplnime rucne
		ld	hl,512
		ld	(MEDSIZE+6),hl
		ret


;zjisteni velikosti media
;(nasledne bude prepsano hodnotou z image)
;ale jeste predtim ulozeno k drivu
;a velikost sektoru
GETPRMA	ld	hl,READCAP
		call	ATAPICOM
		ret	c
		ld	hl,MEDSIZE
		push	hl
		call	READCD
		pop	hl
		ret	c
;uprav cisla na little endian
;(pouze po 16 bitech !!!)
		ld	b,8
		call	PROHOD
;uloz si velikost disku
		ld	hl,(MEDSIZE+2)
		ld	(ix+34),l
		ld	(ix+35),h
		ld	hl,(MEDSIZE)
		ld	(ix+36),l
		ld	(ix+37),h
		ret

;umozni uzivateli zadat prvni sektor iso image
INPUTSEC	rst	24				;call PRINTSP
		defb	22,17,23,16,7+128
		call	LBAS2
		ld	hl,INPBUFF
		ld	(hl),' '+128		;znacka zacatku
		inc	hl
		push	hl
		ld	b,7
		ld	a,32
INPUTSEC4	ld	(hl),a
		inc	hl
		djnz	INPUTSEC4
		ld	(hl),' '+128		;znacka konce
		pop	bc
		ld	iyl,0			;nepis nevyzname nuly
		ld	hl,(ISOSTART+2)
		ld	a,l
		or	h
		call	nz,STO16HX2		;pouze pokud neni 0
		ld	hl,(ISOSTART)
		call	STO16HX2			;pokud uz jednou probehlo, bude v iyl znak 0
INPUTSEC5	ld	hl,0
INPUTSEC2	ld	iy,17*256+15		;pozice
		call	INPUT
		ld	hl,0				;zruseni blikani kurzoru
		ld	(IKURPOS),hl
		ret	c				;stisteno 'edit'
		inc	de				;zustalo od inputu
		call	ATOLH
;pokud se neprecetlo vsechno, znovu
		ld	a,(de)
		cp	' '
		jr	z,INPUTSEC3
		bit	7,a
		ex	de,hl
		call	z,BEEPE
		jr	z,INPUTSEC2		;kurzor tam kde chyba
		ex	de,hl
INPUTSEC3	push	iy
		pop	bc
;nezadano vic nez maximum?
		ld	d,(ix+37)
		ld	e,(ix+36)
		or	a
		sbc	hl,de
		add	hl,de
		ex	de,hl
		jr	c,IVALOK
;je mensi, ne konec
		call	nz,BEEPE
		jr	nz,INPUTSEC5
;rovnaji se, dolni pulka
		ld	h,(ix+35)
		ld	l,(ix+34)
		or	a
		sbc	hl,bc
		call	c,BEEPE
		jr	c,INPUTSEC5
IVALOK	ld	(ISOSTART),bc
		ld	(ISOSTART+2),de
	ifdef WITH_SS
		rst	32
	endif
		ret


;hleda na hdd/cf/zip iso image a nacte primary volume descriptor disku
FINDISO
		rst	24				;call PRINTSP
		defb	22,18,0,18,1,16,2
		defb	" Looking for image, please wait "
		defb	18,0,22,17,16+128
		call	LBAS
		ld	de,(ISOSTART)
		ld	bc,(ISOSTART+2)
		push	ix
;pri stisku SS se hleda hned od dalsiho sektoru, jinak az od velikosti soucasneho image
		call	SSHIFT
		jr	c,FINDISOY
;posun za sektor kde se naleza Primary Volume Descriptor
		ld	ix,16*4+1
		ld	hl,0
		jr	FINDISOX
FINDISOY
		ld	ix,(MEDSIZE+2)		;nizsi
		ld	hl,(MEDSIZE)		;vyssi
;nasobeni 4
		add	ix,ix
		adc	hl,hl
		add	ix,ix
		adc	hl,hl
FINDISOX
		call	ADD3232
		pop	ix
FINDISO3
;test preruseni od uzivatele
		ld	a,127
		in	a,(254)
		rra
		jr	nc,FINDISO7
		push	bc
		push	de
;tiskni jenom "sestnactky"
		ld	a,e
		and	%00001111
		jr	nz,FNDNOPR
;vypis cisla cteneho sektoru
		ld	a,22
		rst	16
		ld	a,17
		rst	16
		ld	a,16
		rst	16
		ld	h,b
		ld	l,c
		call	PRNT12HX
		pop	hl
		push	hl
		call	PRNT16HX
		pop	de
		pop	bc
		push	bc
		push	de
;nacteni sektoru
FNDNOPR	ld	a,1
		ex	af,af'
		ld	hl,BUFFER
		set	6,b
;LBA priznak
		push	hl
;BCDE=LBA sektoru, B+64 pro LBA
;HL=kam sosat
;A'=kolik sektoru
		call	FINDRDS
		pop	hl
;pri chybe zadny image nalezen
		jr	c,NOISOFND
;porovnani signatury primary volume descriptoru
		call	CHECKPVD
		jr	nz,FINDISO5
		pop	de
		pop	bc
;zacatek image je o 16 2048B sektoru drive nez PVD
		ld	hl,16*4
		ex	de,hl
		or	a
		sbc	hl,de
		ex	de,hl
		jr	nc,FINDISO7
		dec	bc
FINDISO7	ld	(ISOSTART),de
		ld	(ISOSTART+2),bc
	ifdef WITH_SS
		rst	32
	endif
		ret

FINDISO5	pop	de
		pop	bc
		inc	de
		ld	a,e
		or	d
		jr	nz,FINDISO2
		inc	bc
FINDISO2	ld	l,(ix+36)
		ld	h,(ix+37)
		or	a
		sbc	hl,bc
		jp	nz,FINDISO3
		ld	l,(ix+34)
		ld	h,(ix+35)
		or	a
		sbc	hl,de
		jp	nz,FINDISO3
		ret

NOISOFND	pop	de
		pop	bc
		ret


;nacti primary volume descriptor
GETPVD	call	RDYCHNG
		ret	nz
		xor	a
		ld	l,a
		ld	h,a
		ld	(MEDSIZE+2),hl
		ld	(MEDSIZE),hl
		ld	(LBADISK),a
		ld	hl,16*256
		ld	(LBADISK+1),hl
;LBA je MSB
		ld	hl,BUFFER
		ld	de,LBADISK
		push	hl
		call	RDWR1SEC
		pop	hl
		ret	c
;je to skutecne PVD?
		call	CHECKPVD
		ret	nz
;je, prenes data
		ld	hl,BUFFER+40
		ld	de,DISKNAME
		ld	bc,32
		ldir
		ld	hl,BUFFER+162+1
		ld	de,LBADISK
		ld	bc,3
		ldir
;prenes velikost iso image musime po pulkach kuli jiz
;hotovemu ostatnimu kodu (pocita s prohozenim po 16b)
		ld	hl,(BUFFER+80)
		ld	(MEDSIZE+2),hl
		ld	hl,(BUFFER+82)
		ld	(MEDSIZE),hl
		ret


;Rambo: first boot part two :)
DASBOOT	ld	a,MAPRPAGE
		out	(RAMPORT),a
		ld	hl,BOOTMEM
		ld	de,8192
		ld	b,d
		ld	c,e
		push	bc
		push	de
		push	hl
		ldir
		xor	a
		out	(RAMPORT),a
;prvni zkus generic boot image (od zacatku media)
		ld	a,4			;4x 2kb
		pop	hl
		push	hl
		ld	de,TUREADY	;potrebujem tri nuly
		call	RDWRSEC
		jp	c,BADBOOT		;chyba pri cteni, ma cenu zkouset el-torito? nejspis ne
		call	CHECKBOOT
		jr	z,BOOTRDY
;generic to neni, zkus el-torito
		xor	a
		pop	hl
		push	hl
		ld	e,l
		ld	d,h
;LBA je MSB
		ld	(hl),a
		inc	hl
		ld	(hl),a
		inc	hl
		ld	(hl),17
		dec	hl
		dec	hl
		push	de
		call	RDWR1SEC
		pop	de
		jr	c,BADBOOT
;porovnani signatury boot volume descriptoru
		inc	de			;bez prvniho byte
		ld	hl,ETSIGN
		ld	bc,15
		call	MEMCMP
		jr	nz,BADBOOT
		ex	de,hl
		ld	bc,55
		add	hl,bc
;tady je LBA LSB :(
		ld	a,(hl)
		inc	hl
		inc	hl
		ld	c,(hl)
;ctvrty LBA byte ignorujeme (na cd nebude nikdy pouzit)
		ld	(hl),a
		dec	hl
		dec	hl
		ld	(hl),c
		ex	de,hl
		pop	hl
		push	hl
		call	RDWR1SEC
		jr	c,BADBOOT
;validation entry neresime
		pop	hl
		push	hl
		ld	bc,32
		add	hl,bc
;default boot entry
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		ld	de,2*256+136	;1.44 disketa a bootable polozka
		ex	de,hl
		sbc	hl,bc		;nc od add hl,bc
		jr	nz,BADBOOT
		ex	de,hl
		ld	bc,7
		add	hl,bc
;tady je LBA taky LSB :(
		ld	a,(hl)
		inc	hl
		inc	hl
		ld	c,(hl)
;ctvrty LBA byte ignorujeme (na cd nebude nikdy pouzit)
		ld	(hl),a
		dec	hl
		dec	hl
		ld	(hl),c
;nas image je jeste o jeden cd sektor dale
		ld	c,1			;v B je 0
		call	ADDLBA2
		ex	de,hl
		pop	hl
		push	hl
		ld	a,4			;4x 2kb
		call	RDWRSEC
		jr	c,BADBOOT
		call	CHECKBOOT
		jr	nz,BADBOOT
;inicializace ram jako po resetu
;jinak od bootu do reseru nesly spoustet snapy
BOOTRDY	ld	a,BACKPAGE
		out	(RAMPORT),a
		ld	hl,TRDOSWRAP+PAGESIGN
		ld	de,TRDOS
		ld	bc,259		;256 + JP TOBASROM
		ldir
;instrukce JP pro snapy
		ld	a,195
		ex	de,hl
;v HL SNARUN
		ld	(hl),a
		ld	a,MAPRPAGE
		out	(RAMPORT),a
;prenes ho do banky 3 a nahod mapram
		pop	hl
		pop	de
		pop	bc
		call	MEMSWAP
		ld	a,MAPRAM
		rst	48				;OR CONMEM
		ld	a,2
		ld	(GPART2),a
		ret

;vratime puvodni pamet
BADBOOT	ld	a,MAPRPAGE
		out	(RAMPORT),a
		pop	de				;zdroj a cil prohodit
		pop	hl
		pop	bc
		ldir
		xor	a
		out	(RAMPORT),a
		ret

;prohodi dva bloky pameti
;HL,DE=ukazatele na zacatky
;BC=delka
MEMSWAP	ld	a,(de)
		ldi
		dec	hl
		ld	(hl),a
		inc	hl
		jp	pe,MEMSWAP
		ret


;je zarizeni pripraveno
;a je treba nacist medium?
;nz=ne, z=ano
RDYCHNG	ld	a,(STATUS)
		dec	a
		ret	nz
		ld	a,(DISKNAME)
		or	a
		ret



;==============================
;nejnizsi rutiny pro ATA/ATAPI
;==============================

ATAPICOM
;v hl adresa 12 bajtu prikazu
		ld	a,CATAPI
		ld	b,0
		ex	af,af'
;fixni max. delka prenosu
		ld	de,2048
		call	IDEOUT2
		ret	c
		ld	bc,256*12+RDATA
		call	IDE_DTRD
		ret	c
		otir
;test konce operace
		call	IDE_DRRD
		ret	c
		in	a,(RSTAT)
		rra
		jp	c,IDEDTRD1
;fakt nevim proc, ale bez toho-
;hle to na nekterych pomalych
;mrchanikach nefunguje :(
		jp	FASTDRQ

;nacte vsechny predane bajty
READCD	call	CMD_DTRD
		ret	c
		in	a,(RCYLH)
		or	a
		jr	z,READCD2
		ld	bc,RDATA
READCD1
		ex	af,af'
		call	IDE_DTRD
		ret	c
		inir
		ex	af,af'
		dec	a
		jr	nz,READCD1
READCD2
;tady mozna problem, pokud cdrom
;zmeni delku behem prenosu
		in	a,(RCYLL)
		or	a
		jr	z,RDCDEND
		ld	b,a
		ld	c,RDATA
		call	IDE_DTRD
		ret	c
		inir
;test konce operace
RDCDEND	call	IDE_DRRD
		ret	c
;na konec jeste pockame
;(potreba pro nektere zvlaste
;pomale mrchaniky s mp drq)
		jp	FASTDRQ

;DE cyl
;B hlava
;C sektor
;A pocet sektoru
;A' prikaz
;MENI: vola drvrdy (DE), AA'F..
IDEOUT	out	(RSECPOC),a
		ld	a,c
		out	(RSEC),a

IDEOUT2
;pro atapi
		ld	a,d
		out	(RCYLH),a
		ld	a,e
		out	(RCYLL),a

		ld	a,(DEVICE)
		or	b
		or	HKONST
		out	(RHEAD),a

		call	IDE_DRRD
		ret	c

		ex	af,af'
		out	(RCOM),a

		or	a
		ret

;jako IDE_DRRD, ale s kratsim timeoutem
IDE_DRRDS	ld	de,IDETOUTS
		jr	IDEDRRD1

;ceka na pripravenost drivu
; not busy & drive ready
;pokud je prectena 0, bude to
;asi vyresetovane ATAPI zariz.
;pokud ne, stejne to vychcipne
;na dalsim testu pripravenosti
IDE_DRRD	ld	de,IDETOUT
IDEDRRD1	in	a,(RSTAT)
		or	a
		ret	z
		and	192
		cp	64
		ret	z
		call	TOUTWT
		jr	nz,IDEDRRD1
		ld	bc,16*7+512			;timeout
		scf
		ret

;ready to transfer pro ATAPI
;s timeoutem a testem busy
;>
; c = error
; nc TrReady
CMD_DTRD	ld	de,IDETOUT
CMDDTRD2	in	a,(RSTAT)
		bit	7,a
		jr	nz,DTROUTC
		rrca
		jr	c,IDEDTRD1
		bit	2,a					;4. bit, je to posunuto
		jr	z,DTROUTC
;pauza 3 ms
FASTDRQ	ld	a,148
ATAWAIT	ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		dec	a
		jr	nz,ATAWAIT
		ret

DTROUTC	call	TOUTWT
		jr	nz,CMDDTRD2
		ld	bc,16*7+512			;timeout
		scf
		ret

;jako IDE_DTRD, ale s kratsim timeoutem
IDE_DTRDS	ld	de,IDETOUTS
		jr	IDEDTRD2

;ready to transfer
;s timeoutem a testem busy
;>
; c = error
; nc TrReady
IDE_DTRD	ld	de,IDETOUT
IDEDTRD2	in	a,(RSTAT)
		bit	7,a
		jr	nz,DTROUT
		rrca
		jr	c,IDEDTRD1
		bit	2,a					;4. bit, je to posunuto
		ret	nz
DTROUT	call	TOUTWT
		jr	nz,IDEDTRD2
		ld	bc,16*7+512			;timeout
		scf
		ret

IDEDTRD1	in	a,(RPARAM)
		ld	c,a
		ld	b,1
		ret


;precte nebo zapise jeden sektor na adresu HL
;ukazatel na lba sektoru v DE
RDWR1SEC	ld	a,1

;precte nebo zapise A sektoru z cdrom na adresu HL
;ukazatel na lba sektoru v DE
;navrat s carry kdyz chyba
;PRIZNAK ZAPISU JE (DOINGWR)!!!
RDWRSEC	push	hl
		ex	af,af'
		ex	de,hl
		ld	c,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	e,(hl)
		pop	hl
		ld	a,(MEDSIZE+7)
		cp	9
		jr	c,READSEC5
;kdyz cdrom vraci vic jak 2048
		ld	a,8
;mozna by tu mohl by jump
READSEC5	cp	3
		jp	nc,READSEC4
;nasobeni 4
		ex	af,af'
		add	a,a
		add	a,a
		ex	af,af'
		ex	de,hl
		ld	a,c
		add	hl,hl
		adc	a,a
		add	hl,hl
		adc	a,a
;pricti start iso image
		ld	bc,(ISOSTART)
		add	hl,bc
		push	hl
;64 je priznak LBA
		ld	h,64
		ld	l,a
		ld	bc,(ISOSTART+2)
		adc	hl,bc
		ld	b,h
		ld	c,l
		pop	hl
		ex	de,hl

;sem volat z hledani iso image
;BCDE=LBA sektoru, B+64 pro LBA
;HL=kam sosat
;A'=kolik sektoru
FINDRDS	ld	a,(DEVICE)
		or	a
		ld	a,(MAS_ATAP)
		jr	z,IDEMAS
		ld	a,(SLA_ATAP)
IDEMAS	dec	a
		jr	z,READSEC4X
;je to hdd/cf, programujem jako ide
	ifdef WITH_CHS
		dec	a
		jr	z,NOCHSHDD
;prevod LBA->CHS
		push	ix
		ld	a,b
		and	%00001111		;pryc konstanty a LBA priznak
		ld	b,a
		ld	a,(DEVICE)
		or	a	
		ld	ix,MAS_NAME
		jr	z,LBA_CHS1
		ld	ix,SLA_NAME
LBA_CHS1	push	hl
		ex	de,hl
		ld	d,(ix+39)
		call	DIV_32_8
;v A sektor
		inc	a			;sektory se cisluji od 1
		push	af
		ld	d,(ix+38)
		call	DIV_32_8
;v A hlava
;v HL cyl
		ex	de,hl
		or	a,HKONST
		ld	b,a
		pop	af
		ld	c,a
		pop	hl
		pop	ix
		jr	CHSHDD
	endif	;WITH_CHS
NOCHSHDD
;prirazeni registru je spatne, prohodit :(
		ld	a,c
		ld	c,e
		ld	e,d
		ld	d,a
CHSHDD	ld	a,(DOINGWR)
		or	a
		ld	a,CREAD
		jr	z,HDDNOWR
		ld	a,CWRITE
HDDNOWR	ex	af,af'
		push	af
		call	IDEOUT
;tady by to asi chtelo test CARRY, ale stejne to kdyztak umre dal
		pop	af
;do A pocet sektoru
		ld	bc,RDATA
		jr	READSEC2


;"osetreni" chyb pri cteni
ERROR2	pop	de
		pop	hl
ERROR	in	a,(RPARAM)
		rra
		rra
		rra
		rra
		out	(254),a
		scf
		ret

;pokracovani rutiny pro cteni/zapis
READSEC4X	ld	a,2
;velikost sektoru (2048 or 512)
READSEC4	out	(RCYLH),a
		xor	a
		out	(RCYLL),a
		push	de
		call	IDE_DRRD
		jr	c,ERROR2
		ld	a,CATAPI
		out	(RCOM),a
		call	CMD_DTRD
		pop	de
		jr	c,ERROR
		ld	a,(DOINGWR)
		or	a
		ld	a,CREAD10A
		jr	z,RDWDCMD
		ld	a,CWRITE10A
RDWDCMD	out	(RDATA),a
		ld	a,c
		ld	bc,RDATA
		out	(c),b
		out	(c),b
		out	(c),a
		out	(c),d
		out	(c),e
		out	(c),b
		out	(c),b
		ex	af,af'
		out	(c),a
		ex	af,af'
		out	(c),b
		out	(c),b
		out	(c),b
		call	FASTDRQ
		in	a,(RSTAT)
		rra
		jr	c,ERROR
		ex	af,af'
;v A pocet sektoru
READSEC2	ex	af,af'
		call	CMD_DTRD
		jr	c,ERROR
		ld	a,(DOINGWR)
		or	a
		jr	nz,WRITESEC
		inir
		inir
		ld	a,(MEDSIZE+7)
		cp	3
		jr	c,READSEC3
		inir
		inir
		inir
		inir
		inir
		inir
READSEC3	ex	af,af'
		dec	a
		jr	nz,READSEC2
		call	FASTDRQ
		in	a,(RCOM)
		rra
		jp	c,ERROR
		ret				;s NC

;lisici se cast pro zapis sektoru
WRITESEC	otir
		otir
		ld	a,(MEDSIZE+7)
		cp	3
		jr	c,READSEC3
;FIXME! sem to nikdy nepujde, nebot CDROM neumi primo zapisovat
;az dojde pamet, tady se da usetrit :)
		otir
		otir
		otir
		otir
		otir
		otir
		jr	READSEC3


;pocitani casu pro timeout
TOUTWT	dec	de
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
		ex	(sp),hl
;trocha casu...
		ld	a,d
		or	e
		ret

;FIXME!!! upravit pro zaporne DE a pricitani (otoci se i podminka)

PRNT16HX	ld	c,'0'
		ld	de,$1000
		call	DIGIT
PRNT12HX	ld	c,'0'
		ld	de,$100
		call	DIGIT
		ld	de,$10
		jr	DECIM1

PRINTHEX	ld	c,'0'
		ld	h,0
		ld	l,a
		ld	de,$10
		jr	DECIM1

PRINTL2	ld	c,'0'
		ld	h,0
		jr	PRINTLX
PRINTL3	ld	c,'0'
		ld	h,0
		jr	PRINTL
PRINTHL	ld	c,' '
PRINTHL2	ld	de,10000
		call	DIGIT
		ld	de,1000
		call	DIGIT
PRINTL	ld	de,100
		call	DIGIT
PRINTLX	ld	de,10
DECIM1	call	DIGIT
		ld	e,1
		ld	c,'0'
DIGIT	ld	a,'0'-1
DIGIT1	inc	a
		or	a
		sbc	hl,de
		jr	nc,DIGIT1
		add	hl,de
		cp	'9'+1
		jr	nc,DIGIT3
		cp	'0'
		jr	nz,DIGIT2
		ld	a,c
		or	a
		call	nz,16
		ret
DIGIT3	add	a,'A'-'9'-1
DIGIT2	ld	c,'0'
		rst	16
		ret

;"tiskne" hex cisla do pameti na adresu v BC
;v iyl znak pro nevyznamne 0
STO16HX	ld	iyl,0
STO16HX2	ld	de,$1000
		call	STRDG
STO12HX	ld	de,$100
		call	STRDG
STO8HX	ld	de,$10
STORXX	call	STRDG
		ld	e,1
		ld	iyl,'0'
STRDG	ld	a,'0'-1
STRDG1	inc	a
		or	a
		sbc	hl,de
		jr	nc,STRDG1
		add	hl,de
		cp	'9'+1
		jr	nc,STRDG2
		cp	'0'
		jr	nz,STRDG3
		ld	a,iyl
		or	a
		ret	z
		jr	STRDG4

STRDG2	add	a,'A'-'9'-1
STRDG3	ld	iyl,'0'
STRDG4	ld	(bc),a
		inc	bc
		ret

;"tiskne" dec cisla do pameti ma adresu v BC
;v iyl znak pro nevyznamne 0
STOR16DC	ld	iyl,0
		ld	de,10000
		call	STRDG
		ld	de,1000
		call	STRDG
STOR8DC	ld	de,100
		call	STRDG
STOR6DC	ld	de,10
		jr	STORXX


;"inicializace" obrazu bez loga
SCRINIT2	call	CLS
		call	ATRIB
;inicializace tiskove rutiny
PRINTINI	xor	a
		ld	hl,ADRVRAM
		ld	(PRINTPOZ),a
		ld	(PRINTPOZ+1),hl
		ld	(ATTRINV),a
		ld	a,7
		ld	(ACTATTR),a
		ld	a,195
		ld	hl,PRINTOUT
		ld	(ACTPRINT),a
		ld	(ACTPRINT+1),hl
		ret

;program pro tisk znaku v reg A
;na adresu v actprint+1 a atributem actattr
PRINTOUT
;je to nejaky ridici znak?
		sub	32
		jr	nc,PRINTZN
		add	a,32
		ld	b,a
		add	a,a
		ld	hl,PRNTTBL
		add	a,l
		ld	l,a
		jr	nc,PRNOUT2
		inc	h
PRNOUT2	ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
;pokud je to 0, nic se nedeje
		or	h
		ret	z
;je to prikaz bez parametru
;(0-15) nebo s (16-31)?
		ld	a,b
		cp	16
		jr	nc,PRNOUT3
;bez, rovnou provedeme
		jp	(hl)

;uloz adresu obsluhy ridiciho
;kodu pro pristi volani
PRNOUT3	ld	(ACTPRINT+1),hl
		ret

;A=znak-32
PRINTZN	ld	c,a
		ld	b,0
;zjisteni tiskove pozice
		ld	a,(PRINTPOZ)
		ld	hl,(PRINTPOZ+1)
		cp	32
		call	z,CTRL_EN2
		push	af
		push	hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
;v radku by nemelo pretect
		add	a,e
		ld	e,a
;adresa znaku
;896*8=7168
		ld	hl,896
		add	hl,bc
		add	hl,hl
		add	hl,hl
		add	hl,hl
;zjisiti inverzi
		ld	a,(ATTRINV)
		ld	c,a
		ld	b,7
		ld	a,(hl)
		xor	c
		ld	(de),a
PRNTZN2	inc	l
		inc	d
		ld	a,(hl)
		xor	c
		ld	(de),a
		djnz	PRNTZN2
;prepocita adresu pixelu
;na adresu atributu
		ld	a,d
		sub	64
		rrca
		rrca
		rrca
		and	3
		add	a,88
		ld	d,a
		ld	a,(ACTATTR)
		ld	(de),a
;posun na dalsi tiskovou pozici
		pop	hl
		pop	af
		inc	a
VRADKU	ld	(PRINTPOZ),a
		ret

;tabulka obsluhy ridicich
;znaku, 0=nezpracovava se
PRNTTBL	defw	0,0,0,0,0,0
		defw	CTRL_COM,0,0
		defw	0,0,0,0,CTRL_ENT
		defw	0,0
;kody 0-15
		defw	CTRL_INK,CTRL_PAP
		defw	CTRL_FLA,CTRL_BRI
		defw	CTRL_INV,0
;over neumime (zbytecny)
		defw	CTRL_AT,CTRL_TAB
		defw	0,0,0,0,0,0,0,0
;kody 24-31

;carka, skok na pozici 0 n. 16
CTRL_COM	ld	a,(PRINTPOZ)
		cp	16
		jr	nc,CTRL_ENT
		ld	a,16
		jr	VRADKU

;enter, prechod na dalsi radek
CTRL_ENT	ld	hl,(PRINTPOZ+1)
		call	CTRL_EN2
		ld	(PRINTPOZ+1),hl
		jr	VRADKU

CTRL_EN2
;prelezli jsme konec radku
;posun na dalsi
		inc	hl
		inc	hl
;posledni radek? (24*2)
		ld	de,ADRVRAM+48
		xor	a
		sbc	hl,de
		add	hl,de
		ret	c
		ld	hl,ADRVRAM
		ret

;nastaveni barvy inkoustu
CTRL_INK	ld	bc,7*256+248
;%00000111, %11111000
CCOLSPOL	and	b
		ld	b,a
		ld	a,(ACTATTR)
		and	c
		or	b
		ld	(ACTATTR),a
CTRLSPOL	ld	hl,PRINTOUT
		ld	(ACTPRINT+1),hl
		ret

;nastaveni barvy papiru
CTRL_PAP	ld	bc,56*256+199
;%00111000, %11000111
		rlca
		rlca
		rlca
		jr	CCOLSPOL

;nastaveni blikani
CTRL_FLA	ld	bc,128*256+127
;%10000000, %01111111
		rrca
		jr	CCOLSPOL

;nastaveni jasu
CTRL_BRI	ld	bc,64*256+191
;%01000000, %10111111
		rrca
		rrca
		jr	CCOLSPOL

;nastaveni inverze (1=on,0=off)
CTRL_INV	or	a
		jr	z,CTRL_IN2
		ld	a,255
CTRL_IN2	ld	(ATTRINV),a
		jr	CTRLSPOL

;nastaveni pozice (AT)
;prvni parametr je radek
CTRL_AT	cp	24
		jr	c,CTRL_AT2
		ld	a,23
CTRL_AT2	add	a,a
		ld	hl,ADRVRAM
		add	a,l
		ld	l,a
		jr	nc,CTRL_AT3
		inc	h
CTRL_AT3	ld	(PRINTPOZ+1),hl
		ld	hl,CTRL_ATS
		ld	(ACTPRINT+1),hl
		ret
;druhy parametr je sloupec
CTRL_ATS	and	31
		ld	(PRINTPOZ),a
		jr	CTRLSPOL

;nastaveni pozice (TAB)
;prvni parametr je sloupec
CTRL_TAB	and	31
		ld	(PRINTPOZ),a
;druhy parametr se ignoruje
		ld	hl,CTRLSPOL
		ld	(ACTPRINT+1),hl
		ret


;konstanty pro polynom
;x16+x15+x2+1 (CRC16)
POLYMASK	equ	128
POLYHI	equ	$80
POLYLO	equ	$05

;obecne texty
MASTER	defb	16,3
		defb	"maste",'r'+128
SLAVE	defb	16,3
		defb	"slave",' '+128

STATTBL	defw	STAT0,STAT1,STAT2
		defw	STAT3,STAT4

STAT0	defb	16,2
		defb	"<not detected",'>'+128
	ifdef WITH_CHS
STAT1	defb	16,4
		defb	"<LBA ready>   "
		defb	16,5+128
STAT1X	defb	16,4
		defb	"<CHS ready>   "
		defb	16,5+128
STATTBL2	defw STAT0,STAT1X,STAT2
		defw STAT3,STAT4
	else
STAT1	defb	16,4
		defb	"<ready>       "
		defb	16,5+128
	endif
STAT2	defb	16,2
		defb	"<not ready>  ",' '+128
STAT3	defb	16,2
		defb	"<medium error",'>'+128
STAT4	defb	16,2
		defb	"<device error",'>'+128

NOTDEV	defb	"not present or device error     "
		defb	0,0

	ifdef WITH_WDC
CHSSUCC	defb "CHS translation: "
	endif

;ATAPI commands:
;read capacity (pokracujem v TUREADY)
READCAP	defw	$25
;test unit ready
TUREADY	defw	0,0,0,0,0,0
;eject removed
;eject medium
;EJECT	defw	$1B,0,2,0,0,0

;podle ceho se poznava ISO image pri hledani
ISOSIGN	defb	1
ETSIGN	defb	"CD001"			;spolecne pro ISO i EL TORITO
;podle ceho se pozna EL TORITO
		defb	1,"EL TORITO"

;tabulka pro prekodovani kodu
;klaves z KEYSCANu
KEYSTAB	defb	"bhy65tgv"
		defb	"nju74rfc"
		defb	"mki83edx"
		defb	0,"lo92wsz"
		defb	' ',13,"p01qa"
		defb	0
KEYSCSTAB	defb	"BHY",10,8,"TGV"
		defb	"NJU",11,5,"RFC"
		defb	"MKI",9,4,"EDX"
		defb	0,"LO",14,6,"WSZ"
		defb	' ',13,'P',12,7,"QA"
		defb	0
KEYSSSTAB	defb "*^[&%>}/"
		defb ",-]'$<{?"
		defb ".+",127,"(#"		;(c)
		defb	16,92,96			;(SS+E=16), backslash, pound
		defb	0,"=;)@",15,"|:"	;(SS+W=15)
		defb	" ",13,34,"_!",14	;(SS+Q=14)
		defb "~",0

;kody klaves NMI menu spolecne s obsluznymi programy
NMIPROG	defb	'q'
		defw	QUIT
;eject removed
;		defb	'e'
;		defw	EJMED
		defb	'r'
		defw	RESET
		defb	'm'
		defw	MEDIUM
		defb	'd'
		defw	CHDEV
		defb	'i'
		defw	DEMINT
		defb	'f'
		defw	FINDIMG
		defb	's'
		defw	SECTIMP
		defb	'v'
		defw	VRAMSEL
		defb	'p'
		defw	DIPAGING
	ifdef WITH_POK
		defb	'c'
		defw	ENTPOKMAN
	endif
		defb	13
		defw	ENTBROWS
		defb	0

;adresy zacatku radku ve VRAM
;(drive se generovaly, ale ted je ROM dost)
ADRVRAM	defw 16384
		defw	16384+32
		defw	16384+64
		defw	16384+96
		defw	16384+128
		defw	16384+160
		defw	16384+192
		defw	16384+224
		defw	18432
		defw	18432+32
		defw	18432+64
		defw	18432+96
		defw	18432+128
		defw	18432+160
		defw	18432+192
		defw	18432+224
		defw	20480
		defw	20480+32
		defw	20480+64
		defw	20480+96
		defw	20480+128
		defw	20480+160
		defw	20480+192
		defw	20480+224

ROMEND0

;strankovani zpet do ROM ZXS
		org	$1FF6
EIROM2	pop	af
EIROM	ei
;o strankovani se stara HW
TOBASROM	ret
ROMJPHL	jp	(hl)


;font
FONT		equ	8192-1024
		org	FONT
	ifdef BOLD_FONT
		binclude "didaktik.font"
	else
		binclude "spectrum.font"
	endif

;fixme!
;od konce fontu 7936 (FONT+768) az do EIROM2 je volne misto, pouzit


	if USELOGO = 0
LOGO		equ	FONT-36
		org	LOGO
		rst	24				;call PRINTSP
		defb 22,8,2,16,3,19,1
		defb "DTP's Emulator Files Runne",'r'+128
		ret
	endif

	if USELOGO = 1
LOGO		equ	FONT-622
		org	LOGO
		binclude "logo.pck"
	endif

	if USELOGO = 2
LOGO		equ	FONT-860
		org	LOGO
		binclude "logof6.pck"
	endif

	if USELOGO = 3
LOGO		equ	FONT-636
		org	LOGO
		binclude "logof6_2.pck"
	endif



;druha cast, file browser, obsluha ruznych emulatorovych souboru
;bezi v MAPRAM

		org	8192
		phase 0
		di
		xor	a
		out	(RAMPORT),a
		jp	DORESETR
RST0ENDR

		org	8192+8
		phase 8
;rst 8 - error
;s tim nic delat nebudem
A0008R	ld	hl,($5C5D)
A0008RR	push	hl
		ld	l,A0008RR
		jr	CONTEXR
RST8ENDR

		org	8192+16
		phase 16
;rst 16 - tisk znaku
		rst	40
		defw	16
		ret
RST16ENDR

		org	8192+24
		phase 24
;rst 24 - tisk retezce za instrukci rst (PRINTSP)
		pop	hl
		call	PRINT128R
		jp	(hl)
RST24ENDR

;sem pri intu pri pristrankovanem DEMFIRu
;pocita s ld hl,xxx na dalsim byte!!!
		org	8192+31
		phase 31
		defb	24			;jr 66 (ROMINTR)

;rst 32 - reset screensaveru
		ld	hl,SSAVER		;opcode se pouziva pro JR z predesle adresy!
		ld	a,l
		ld	(SSTIMER),a
		ret
RST32ENDR

		org	8192+40
		phase 40
;rst 40 - volani druhe ROM (MAPRAM)
		ex	(sp),hl
		ld	(TMPDE),de
		ld	e,(hl)
		jr	RST40CNTR
RST40ENDR

		org	8192+48
		phase 48
;rst 48 - strankovani RAM
;v A cislo RAM stranky
;stack safe, ale nici HL
		pop	hl
		out	(RAMPORT),a
		jp	(hl)
RST48ENDR

;preruseni je potreba
;zneuzijeme k pocitani casu...
		org	8192+56
		phase 56

A0038R	defb	24
A0038RR	push	hl
		ld	l,A0038RR
CONTEXR	ld	h,0			;sice delsi, ale vejde se u RST8
		ex	(sp),hl
		jp	TOBASROM

ROMINTR	push	af
		push	hl
		ld	hl,INTCNT
		inc	(hl)
		jr	nz,INT1R
		inc	hl
		inc	(hl)
		inc	hl
		ld	a,(hl)
		or	a
		jr	z,INT1R
		dec	(hl)
INT1R	pop	hl
		pop	af
		ei
;		ret			;pokracuje dalsim byte!

;		org	8192+85
;		phase 85
;sem pri NMI pri pristrankovanem DEMFIRu
;a pouziva i depak LOGA (detekce adresy)
		ret				;musi byt na adrese 85!!!

;pokracovani volani druhe ROM
RST40CNTR	inc	hl
		ld	d,(hl)
		inc	hl
		ex	(sp),hl
		call	PREPDER
OUTPAGER	push	af
		ld	a,CONMEM
		out	(RAMPORT),a
		pop	af
		ret
R40CENDR

		org	8192+102
		phase 102

;obsluha NMI
;pri stisku nmi se prestrankuje az na adrese 103
;pri sifrovani tlacitka se skace na 102

		defb	24
;musi byt pristrankovana BACKPAGE
;vsechno pouzite uschovej
;(push af jeste z puvodni ROM)
		ld	(ORGSTACK),sp
		ld	sp,BACKSTACK
;stav preruseni (obsah R ztracen)
		ld	a,i
		push	af
		ld	a,255
		jp	pe,STOREINTR
		xor	a
STOREINTR	push	hl
		push	de
		push	bc
		push	ix
		push	iy
		exx
		push	hl
		push	de
		push	bc
		ex	af,af'		;v af` EIDI 
		push	af
;test modu preruseni
		ld	hl,15104		;59*256
		ld	b,0			;plni se 257B
		ld	a,h
		ld	i,a
		inc	a			;A=60
MAKEIM2R	ld	(hl),a
		inc	hl
		djnz	MAKEIM2R
		ld	(hl),a
;ld hl,xx
		defb	33
		xor	a
		ret
		ld	(15420),hl
;15420=60*256+60
		ei
		halt
		di
		im	1
;zaloha VRAM a printbufferu
		ld	hl,16384
		ld	de,BACKVRAM
		ld	bc,BVLEN
		ldir
		ld	b,a
		ld	sp,NMISTACK
;pro maximalni vyuziti pameti podminenym prekladem modifikovatelne casti az po
;vstupnich bodech pro LD/SA-BYTES
		rst	40
		defw	NMIBPGS
;dal by to nemelo pokracovat

;cast strenkovani CONMEM/MAPRAM
PREPDER	push	de
		ld	de,(TMPDE)
		jr	OUTPAGER

;druha cast navratu (potrebujem v CONMEM i MAPRAM)
;zrcadlo z CONMEM
QUIT2R	out	(RAMPORT),a
		ld	sp,BACKSTACK-20	;10x push
;HL=BACKVRAM+6912 DE=23296 BC=0
		ld	b,(BVLEN-6912)/256
		ldir
		pop	af
		ex	af,af'
		pop	bc
		pop	de
		pop	hl
		exx
		pop	iy
		pop	ix
		pop	bc
		pop	de
		pop	hl
		pop	af
		ld	sp,(ORGSTACK)
		ld	i,a
;bylo povolene preruseni?
		jp	pe,EIROM2
		pop	af
;zakazane preruseni
		jp	TOBASROM
OVRLENDR

;tiskaci podprogramy
PRINT128R	ld	a,(hl)
		and	127
		rst	16
		bit	7,(hl)
		inc	hl
		jr	z,PRINT128R
		ret

;beep
BEEPR	push	hl
		push	af			;potrebujem zachovat flagy kuli snadnemu volani
		ld	de,256
		ld	hl,384
		rst	40
		defw	BEEPER
		pop	af
		pop	hl
		ret

;sem to skace po resetu (MAPRAM)
DORESETR	ld	sp,NMISTACK	;je celkem jedno kde
		rst	40
		defw	SCRINIT
;48K BASIC se strankovanim 128K
	ifdef ROM_2A_3
;i pro +2A/+3
		ld	bc,8189
		ld	a,4
		out	(c),a
	endif
		ld	a,16+64
		out	(253),a
;DORESETR2
;spocitame CRC CONMEM (!!!)
;kdyz nesedi, bud nova verze ROM nebo spatna data v RAM
		ld	hl,0
		ld	bc,8192		;cela ROM
		rst	40
		defw	CNTCRC
		ex	de,hl
		ld	hl,(ROMCRC)
		or	a
		sbc	hl,de
		jr	z,CRCOKR
		push	de
		rst	40
		defw	CLRPG2
		pop	hl
		ld	(ROMCRC),hl
;jsme MAPRAM, tak si to zapamatujem
		ld	a,2
		ld	(GPART2),a
CRCOKR
;init screenseveru
	ifdef WITH_SS
		rst	32
	endif
		ld	a,BACKPAGE
		rst	48
;kdyby nekdo nahodou volal TRDOS
;zbytecne pro CRCOK, ale zas neni problem se strankovanim
		ld	hl,TRDOSWRAP
		ld	de,TRDOS
		ld	bc,259		;256 + JP TOBASROM
		ldir
;instrukce JP pro snapy
		ld	a,195
		ex	de,hl
;v HL SNARUN
		ld	(hl),a
	ifdef STDRST
		ld	hl,1
	else
;workaround pro ISOROM a podobne hruzy
		xor	a
		ld	de,$FFFF
		ld	hl,$11CB
	endif
		jp	ROMJPHL

;data pro TRDOS wrapper (259B)
;momentalne prazdno, ale casem by mohlo obsahovat
;vstupni body pro "emulaci" cteni z .TRD
TRDOSWRAP
		defb 256 dup (0)
		jp	TOBASROM
;fixme - presunout nekam pouzitelne


BEF_SVBR
;odchyceni save (jen pokracuje zpet v ZX ROM)
		org	8192+$4C6
		phase $4C6
GAP_SVBR	equ	$-BEF_SVBR

		ld	hl,$1F80
;z puvodni ROM
		push	hl
		ld	hl,$4C6+3
		ex	(sp),hl
		jp	TOBASROM

;konec odchyceni save


;naboucha do AY data z (HL)
AYSOUND	ld	c,253
		ld	de,16
AYFILL	ld	a,(hl)
		ld	b,255
		out	(c),d
		ld	b,191
		out	(c),a
		inc	hl
		inc	d
		dec	e
		jr	nz,AYFILL
		ret

;vrati v HL a IX adresu souboru v bufferu
;v DE adresu polozky v indexu
GETFILE	ld	a,(POZICE)
		add	a,a
		ld	hl,(VYPIS)
		ld	e,a
		ld	d,0
		add	hl,de
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		dec	hl
		ex	de,hl
		push	hl
		pop	ix
		ret


BEF_LDBR
;tape emulator
		org	8192+$562
		phase $562
GAP_LDBR	equ	$-BEF_LDBR

LD_BYTES	in	a,($FE)
;in je z originalni ROM
		xor	a
		out	(RAMPORT),a			;potrebujem zachovat HL
		ld	a,(TAPACT)
		or	a
		jr	nz,TPEMUL
;neni vybrana zadna tapka
;vrat se do normalniho ld-bytes
		ld	hl,LD_BYTES+2
		push	hl
		in	a,($FE)
		jp	ROMSRAM

;preruseni by melo byt, ale pro jistotu
TPEMUL	di
;test na verify
		ex	af,af'
		jr	c,TPEML3
		add	ix,de
		ld	de,0
;verify OK
		scf
		jp	ROMSRAM

TPEML3	ex	af,af'
;break
		ld	a,127
		in	a,(254)
		rra
		jp	nc,ROMSRAM
		ld	hl,(TAPCURS)
TPEML2
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		inc	hl
		ld	a,b
		or	c
		jr	nz,TPEML1
;konec tapky, "previn pasek"
		ld	hl,INDEX+4
		jr	TPEML2
TPEML1	ld	(TAPCURS),hl
		ld	l,c
		ld	h,b
;test flagu
		ex	af,af'
		cp	(hl)
		jr	nz,TPEML3
		inc	hl
;test delky
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		inc	hl
		ex	de,hl
		or	a
		sbc	hl,bc
		add	hl,bc
		ex	de,hl
;		jr	nz,TPEML3
		jr	c,TPCONT
;korekce pro priblbly loadery co nevedi co chteji
;stejne se mi to takhle nelibi
		ld	d,b
		ld	e,c
TPCONT	ld	bc,17
		or	a
		jr	nz,TPTELO
		ex	de,hl
		sbc	hl,bc
		add	hl,bc
		ex	de,hl
		jr	nz,TPTELO
;prenes hlavicku
		push	ix
		pop	de
		call	SELFPROT
		jr	c,TPSPOL
		ldir
		jr	TPSPOL

;test na std. blok, ostatni preskoc
TPTELO	ld	a,(hl)
		cp	$10
		jr	nz,TPEML3
		inc	hl
		push	ix
		push	de
		push	hl
		rst	40
		defw	CAINIT
;zjisteni stavu zarizeni
;(vzpamatovani po resetu)
		ld	a,(DEVICE)
		and	16
		ld	ix,MAS_NAME
		jr	z,TPTELOX
		ld	ix,SLA_NAME
TPTELOX	rst	40
		defw	GETREADY
		pop	hl
		inc	hl		;preskoceni LBA
		inc	hl
		inc	hl
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		rst	40
		defw	CASEEK
		pop	bc
		pop	de
;chyba pri cteni
		jr	c,TPSPOL
		ld	hl,0
		call	SELFPROT
		jr	c,TPSPOL
		ld	a,l
		or	h
		jr	z,NOCORR
;byla korekce adresy, musime
;se posunout v souboru
		push	bc
		push	de
		ld	b,h
		ld	c,l
		rst	40
		defw	CASEEK
		pop	de
		pop	bc
		jr	c,TPSPOL
NOCORR	rst	40
		defw	CAREAD
;schovej si uspesnost cteni
TPSPOL	push	af
		push	de
;tady test na konec tapky znovu
;jinak se ztraci kurzor na
;konci tapky (pri vypisu)
		ld	hl,(TAPCURS)
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		or	h
		jr	nz,TPSPOL2
;konec tapky, "previn pasek"
		ld	hl,INDEX+4
		ld	(TAPCURS),hl
TPSPOL2
;korekce spravnych load hodnot
		ld	de,0
		pop	ix
		pop	af
		ccf
		jp	ROMSRAM

;Zjisti, jestli pozadovany blok
;neprepise cast ROM. Pokud jde,
;oprav registry, pokud uplne
;mimo, navrat s C.
SELFPROT	push	hl
		ex	de,hl
		ld	de,16384
		or	a
		sbc	hl,de
		jr	nc,SEPR2
		add	hl,bc
;jsi uplne mimo, navrat
;na HL a DE nezalezi
		jr	nc,SEPR3
		ld	d,b
		ld	e,c
		ex	de,hl
		ld	c,e
		ld	b,d
		or	a
		sbc	hl,de
		pop	de
		add	hl,de
		ld	de,16384
;NC od ADD (doufam)
		ret

SEPR2	add	hl,de
		ex	de,hl
		scf
SEPR3	ccf
		pop	hl
		ret

;konec tape emulatoru

CARDONE2	dec	de
;vrati v A dalsi byte z cache
;prevraci banky registru!
;C chyba (zustanou ' reg)
CARDONE	exx
		ld	hl,(CACHEREM)
		ld	a,h
		or	l
		jr	z,CARDO1
		dec	hl
		ld	(CACHEREM),hl
		ld	hl,(CACHEKUR)
CARDO2	ld	a,(hl)
		inc	hl
		ld	(CACHEKUR),hl
		or	a
		exx
		ret

CARDO1	ld	hl,CACHE
		ld	de,CACHELBA
		rst	40
		defw	RDWR1SEC
		ret	c
		rst	40
		defw	INCLBA
		ld	hl,2047
		ld	(CACHEREM),hl
		ld	hl,CACHE
		jr	CARDO2





;program pro urceni souboru
CDBROWS	rst	40
		defw	PRINTINI
AGAIN	di
;inicializace hledani souboru
		xor	a
		ld	(FFCNT),a
		ld	a,(TAPACT)
		or	a
		jp	nz,NEXTPG
		ld	a,(DISKACT)
		or	a
		jp	nz,NEXTPG
		ld	hl,1
		ld	(ACTSDIR),hl
		rst	40
		defw	GETISO1
;FIXME! osetreni chyby
		ret	c
		ld	ix,BUFFER
		push	ix
		ld	l,(ix+11)
		ld	h,(ix+12)
		ld	a,(ix+13)
;delka adresare v bytech
		or	a
		rra
		rr	h
		rr	l
		or	a
		rra
		rr	h
		rr	l
		or	a
		rra
		rr	h
		rr	l
;delka adresare v sektorech
		ld	(DIRLEN),hl
		ld	l,(ix+0)
		ld	h,0
		pop	bc
		add	hl,bc
;v hl adresa prvniho souboru
		rst	40
		defw	GETISO2
		ld	a,255
		ld	(DISKACT),a
TAPBROWS	ld	a,4*8
BROWSTR	ld	(KURCOL),a
TPBRSNC	ld	hl,INDEX+2
		ld	(VYPIS),hl
		xor	a
		ld	(POZICE),a

NEXTPG	rst	40
		defw	CLS
	ifdef WITH_SS
		rst	32
	endif
		rst	24				;call PRINTSP
		defb	22,0,0,16,7+128
		ld	de,(VYPIS)
		ld	b,22
TISKSM	ld	hl,(TAPCURS)
		or	a
		sbc	hl,de
		ld	c,' '
		jr	nz,TPCTST
		ld	c,'>'
TPCTST	ex	de,hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ex	de,hl
		ld	a,h
		or	l
		jp	z,ENDTISK
		push	de
		push	bc
		ld	a,(TAPACT)
		or	a
		jp	z,ISOLIST
		inc	hl
		ld	a,h
		or	l
		dec	hl
		jr	nz,TAPLIST
		rst	24				;call PRINTSP
		defb	"/.",'.'+128
		jp	DIRSPOL

TAPLIST	ld	a,c
		rst	16
		ld	a,(hl)
		inc	hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		or	a
;pokud flag != 0, je to telo
		jr	nz,LITELO
;nc
		ld	bc,17
		ex	de,hl
		sbc	hl,bc
		add	hl,bc
		ex	de,hl
;pokud flag=0, ale delka != 17
		jr	nz,LITELO
;je to hlavicka
		ld	a,(hl)
		inc	hl
		push	hl
		rst	40
		defw	PRINTHEX
		ld	a,32
		rst	16
		pop	hl
		ld	b,10
		rst	40
		defw	PRINTB
		ld	a,32
		rst	16
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		inc	hl
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
		push	hl
		push	bc
		ex	de,hl
		rst	40
		defw	PRINTHL
		ld	a,32
		rst	16
		pop	hl
		rst	40
		defw	PRINTHL
		ld	a,32
		rst	16
		pop	hl
		rst	40
		defw	PRINTHL
		jp	DIRSPOL

;vypis dat od TZX
LITELO	ld	c,a
		ld	a,(hl)
		cp	$10
		jr	z,LITELO2
;tisknot i delku v DE? asi ne
		push	af
		rst	40
		defw	PRINTHEX
		pop	af
	ifdef WITH_MTF
		ld	l,a
		ld	h,0
		ld	a,' '
		rst	16
		add	hl,hl
		ld	de,TZXTEXTS
		add	hl,de
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
		call	PRINT128R
	else ;WITH_MTF
		rst	24				;call PRINTSP
		defb	" TZX extended databloc",'k'+128
	endif ;WITH_MTF
		jr	DIRSPOL

;std. bloky
LITELO2	push	de
		ld	a,c
		rst	40
		defw	PRINTHEX
		rst	24				;call PRINTSP
		defb	" <-body->  ",' '+128
		pop	hl
		rst	40
		defw	PRINTHL
		jr	DIRSPOL

ISOLIST	push	hl
		pop	ix
		ld	bc,33
		add	hl,bc
		ld	a,(hl)
		dec	a
		jr	nz,NETECKY
;o uroven vyse
		rst	24				;call PRINTSP
		defb	"/.",'.'+128
;		jr	PJM2
		jr	DIRSPOL

NETECKY	dec	hl
		ld	a,(hl)
;tiskni max 31 znaku
		cp	31
		jr	c,PJMXX
		ld	a,31
PJMXX	ld	b,a
		ld	a,' '
		bit	1,(ix+25)
		jr	z,NODIR
		ld	a,'/'
NODIR	rst	16
PJMSM1	inc	hl
		ld	a,(hl)
		cp	';'
;strednik oddeluje cislo verze
;souboru (k nicemu)
;		jr	z,PJM2
		jr	z,DIRSPOL
		rst	16
		djnz	PJMSM1

;PJM2	ld	a,23
;		rst	16
;		ld	a,23
;		rst	16
;		rst	16
;		bit	1,(ix+25)
;		jr	z,NODIR
;		rst	24				;call PRINTSP
;misto delky jen text "dir"
;		defb	"<DIR>",' '+128
;		jr	DIRSPOL

;NODIR	ld	l,(ix+10)
;		ld	h,(ix+11)
;		ld	e,(ix+12)
;		ld	d,(ix+13)
;		ld	a,' '
;		rst	40
;		defw	PRSIZE
;		ld	a,23
;		rst	16
;		ld	a,31
;		rst	16
;		rst	16
;		ld	a,b
;		rst	16

DIRSPOL	ld	a,13
		rst	16
		pop	bc
		pop	de
		dec	b
		jp	nz,TISKSM

ENDTISK	ei

VYBER	call	KURZOR
		ld	a,(TAPACT)
		or	a
		jr	nz,VYBERSM
		ld	a,(FFCNT)
		or	a
		jr	z,FLPRM
		ld	b,a
		rst	24
		defb	22,23,0,"Search:",' '+128
		ld	hl,INPBUFF
		rst	40
		defw	PRINTB
;	ifdef WITH_SS
;		rst	32
;	endif
		jr	VYBERSM

FLPRM	call	GETFILE
		rst	40
		defw	FILEPARM
VYBERSM
		rst	40
		defw	INKEYS
;TRUE_VIDEO je prefix, ber dalsi znak jako znak pro hledani
		cp	4
		jr	nz,BROWKEYS
		ld	a,1
		out	(254),a
		rst	40
		defw	INKEYS
		xor	a
		out	(254),a
		jp	FILEFIND

;nejde pouzit to u NMI, jina ROM
;FIXME! nejak spojit s klavesami u pokemanageru
BROWKEYS	ld	hl,BRPROG
BRK1		ld	a,(hl)
		or	a
		jp	z,FILEFIND
		cp	d
		inc	hl
		jr	z,BRK2
		inc	hl
		inc	hl
		jr	BRK1

BRK2		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
		jp	(hl)

UP
;	ifdef WITH_SS
;		rst	32
;	endif
		ld	a,(POZICE)
;test zac. stranky
		or	a
		jr	nz,UP2
		call	DOPGUP
		jr	c,VYBERSM
		ld	a,21
		ld	(POZICE),a
		jp	NEXTPG

UP2
;test zac. indexu
		ld	hl,(VYPIS)
		ld	b,a
		add	a,a
		ld	e,a
		ld	d,0
		add	hl,de
		dec	hl
		ld	a,(hl)
		dec	hl
		or	(hl)
		jr	z,VYBERSM
		dec	b
UDSPOL	ld	a,b
		ld	(POZICE),a
;zrusi hledani
		ld	hl,FFCNT
		ld	a,(hl)
		or	a
		jp	z,VYBER
		ld	(hl),0
		jp	CLSTATUS

DOWN
;	ifdef WITH_SS
;		rst	32
;	endif
		ld	a,(POZICE)
;test na max. radku
		cp	21
		jr	nz,DOWN2
		call	DOPGDW
		jp	c,VYBERSM
		xor	a
		ld	(POZICE),a
		jp	NEXTPG
DOWN2
;test na konec indexu
		ld	hl,(VYPIS)
		ld	b,a
		inc	a
		add	a,a
		ld	e,a
		ld	d,0
		add	hl,de
		ld	a,(hl)
		inc	hl
		or	(hl)
		jp	z,VYBERSM
		inc	b
		jr	UDSPOL

PGUP
;	ifdef WITH_SS
;		rst	32
;	endif
		ld	b,0
		ld	a,(POZICE)
		or	a
		jr	nz,UDSPOL
		call	DOPGUP
		jp	c,VYBERSM
;zrusi hledani
		xor	a
		ld	(FFCNT),a
		jp	NEXTPG

PGDW
;	ifdef WITH_SS
;		rst	32
;	endif
		ld	a,(POZICE)
		cp	21
		jr	nz,PGDW2
		call	DOPGDW
		jp	c,VYBERSM
		jp	NEXTPG

PGDW2	ld	hl,(VYPIS)
		ld	de,44			;2*(21+1)
		add	hl,de
		ld	b,22
PGDW3	dec	b
		ld	a,(hl)
		dec	hl
		or	(hl)
		dec	hl
		jr	z,PGDW3
		ld	a,(POZICE)
		cp	b
		jp	z,VYBERSM
		jr	UDSPOL


DOPGUP	ld	hl,(VYPIS)
		ld	de,22*2
		or	a
		sbc	hl,de
		ld	de,INDEX+1		;musi platit c i pro z
;vzdy NC
		sbc	hl,de
		add	hl,de
		jp	nc,DOPGSPL
;jestli ma adresar predesly sektor, nacteme ho
;jestli aktivni tapka, navrat
		ld	a,(TAPACT)
		or	a
		scf
		ret	nz
;jsou nacteny 2 sektory, ale ulozene je cislo prvniho
		ld	hl,(ACTSDIR)
		dec	hl
		ld	a,l
		or	h
		scf
		ret	z
		ld	hl,LBADISK
		ld	bc,1
		rst	40
		defw	SUBLBA2
;druhy sektor by sel v pameti presunout ldirem, ale muselo
;by se to sloziteji testovat, takhle to neni o moc pomalejsi
		rst	40
		defw	GETISO1
;FIXME! osetreni chyby
		ret	c
;posun vsechny ukazatele
;tohle by slo i drive, ale po prip.chybe cteni by to bylo spatne
		ld	hl,(ACTSDIR)
		dec	hl
		ld	(ACTSDIR),hl
		dec	hl
;pokud se jedna o 1 sektor adr.
		ld	a,l
		or	h
		ld	hl,BUFFER
		jr	nz,DOPGUP2
;preskoc prvni polozku
		ld	e,(hl)
		ld	d,0
		add	hl,de
DOPGUP2	rst	40
		defw	GETISO2
;kolik polozek pridame? (pocet zaznamu z nacteneho sektoru)
		ld	hl,(ADR2SEC)
;+44 je posun na dalsi stranku
		ld	de,INDEX+2+44
		or	a
		sbc	hl,de
		ld	de,(VYPIS)
		add	hl,de
		ld	(VYPIS),hl
		or	a
RET2MAIN	ret			;pouzito jenom jako ret

;posun na dalsi stranku
DOPGDW	ld	hl,(VYPIS)
		ld	de,22*2
		add	hl,de
		ld	de,INDEX+588
		or	a
		sbc	hl,de
		add	hl,de
		push	hl
		jr	nc,DOPGDWX
;posun na konec stranky
		ld	de,21*2
		add	hl,de
		ld	de,INDEX+588
		or	a
		sbc	hl,de
		add	hl,de
		jr	nc,DOPGDWX
;test konce ve vypisu
		ld	a,(hl)
		inc	hl
		or	(hl)
		jr	nz,DOPGSPL2
DOPGDWX	call	DOPGDW2
		pop	hl
;kdyz nc, uz je vse udelano
		ret	nc
		ld	(VYPIS),hl
		jp	FINDEND

DOPGSPL2	pop	hl
DOPGSPL	ld	(VYPIS),hl
		or	a
		ret

;jestli ma adresar dalsi sektor, nacteme ho
;jestli aktivni tapka, navrat
DOPGDW2	ld	a,(TAPACT)
		or	a
		scf
		ret	nz
		ld	hl,(DIRLEN)
;adresar ma jen jeden sektor?
		dec	hl
		ld	a,l
		or	h
		scf
		ret	z
;jsou nacteny 2 sektory, ale ulozene je cislo prvniho
		ld	bc,(ACTSDIR)
		or	a
		sbc	hl,bc
		scf
		ret	z
		ld	hl,LBADISK
		ld	bc,1
		rst	40
		defw	ADDLBA2
;druhy sektor by sel v pameti presunout ldirem, ale muselo
;by se to sloziteji testovat, takhle to neni o moc pomalejsi
		rst	40
		defw	GETISO1
;FIXME! osetreni chyby
		ret	c
;posun vsechny ukazatele
;tohle by slo i drive, ale po prip.chybe cteni by to bylo spatne
;kolik polozek ubereme?
		ld	hl,(ACTSDIR)
		inc	hl
		ld	(ACTSDIR),hl
		ld	hl,(ADR2SEC)
;+44 je posun na dalsi stranku
		ld	de,INDEX+2+44
		or	a
		sbc	hl,de
		ex	de,hl
		ld	hl,(VYPIS)
		or	a
		sbc	hl,de
		ld	(VYPIS),hl
		push	hl
		ld	hl,BUFFER
		rst	40
		defw	GETISO2
		pop	hl
;najdi konec zaznamu
FINDEND	ld	de,44			;2*(21+1)
		add	hl,de
		ld	b,22
DOPGDWY	dec	b
		ld	a,(hl)
		dec	hl
		or	(hl)
		dec	hl
		jr	z,DOPGDWY
		ld	a,b
		ld	(POZICE),a
		or	a
		ret

;hledani souboru psanim jeho jednotlivych znaku
FILEFIND	ld	a,(TAPACT)
		or	a
		jp	nz,VYBERSM
		ld	hl,FFCNT
		ld	a,d
		cp	12				;backspace
		ld	a,(hl)
		jr	nz,FLFND2
		or	a
		call	z,BEEPR
		jp	z,VYBERSM
		dec	(hl)
		jp	CLSTATUS

FLFND2	cp	12				;max. pocet znaku
		call	nc,BEEPR
		jp	nc,VYBERSM
		ld	c,a
		ld	b,0
		inc	(hl)
		ld	hl,INPBUFF
		add	hl,bc
		ld	(hl),d
;samotne hledani
;aktualni soubor odpovida? pak neni potreba dal hledat
		call	GETFILE
;DE=index, HL=polozka, BC=delka hledani (B=0)
		push	bc
		push	de
		call	BUFFCMP
		pop	hl
		pop	bc
		jp	z,CLSTATUS	;kdyz se rovnaji, finito
		jr	nc,SRCHDWN	;hledat dopredu nebo dozadu?

;hledani smerem k prvni polozce
;hloupate linearni prohledavani, vzhledem ke strukture ISO9660 asi nic
;chytrejsiho nepujde :(
SRCHUP	ld	a,2*8
		push	bc
		call	KURZORC
		pop	bc
		ld	a,(POZICE)
		ld	b,a
SRCHUP2
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		dec	hl
		dec	hl
		dec	hl
		push	hl
		push	bc
		ex	de,hl
		call	BUFFCMP
		pop	bc
		pop	hl
		jr	nc,SRCHUP3
		dec	b
		bit	6,b
		jr	z,SRCHUP2
		push	bc
		call	DOPGUP
		pop	bc
		jr	c,SRCHUP3
		ld	b,128+22
		ld	hl,(VYPIS)
		ld	de,22*2
		add	hl,de
		jr	SRCHUP2

SRCHUP3	ld	a,b
		and	127
		ld	(POZICE),a
		bit	7,b
		jp	z,CLSTATUS
		jp	NEXTPG


;hledani smerem k posledni polozce
;hloupate linearni prohledavani, vzhledem ke strukture ISO9660 asi nic
;chytrejsiho nepujde :(
SRCHDWN	ld	a,2*8
		push	bc
		call	KURZORC
		pop	bc
		ld	a,(POZICE)
		ld	b,a
SRCHDWN2	ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	a,(hl)			;konec adresare
		inc	hl
		or	(hl)
		jr	z,SRCHDWN3
		dec	hl
		push	hl
		push	bc
		ex	de,hl
		call	BUFFCMP
		pop	bc
		pop	hl
		jr	z,SRCHDWN3
		jr	c,SRCHDWN3
		inc	b
		ld	a,b
		and	127
		cp	22
		jr	c,SRCHDWN2
		push	bc
		call	DOPGDW
		pop	bc
		jr	c,SRCHDWN3
		ld	b,128
		ld	hl,(VYPIS)
		jr	SRCHDWN2

SRCHDWN3	ld	a,b
		and	127
		ld	(POZICE),a
		bit	7,b
		jp	z,CLSTATUS
		jp	NEXTPG

;smazani spodniho radku
CLSTATUS	rst	24
		defb	22,23,128
		rst	40
		defw	SPACES
		jp	VYBER

;vybran nejaky soubor
ENTER
;	ifdef WITH_SS
;		rst	32
;	endif
		call	GETFILE
		ld	a,(TAPACT)
		or	a
		jp	z,ENTER2
		inc	hl
		ld	a,l
		or	h
		jr	z,LEAVETAP
		dec	hl
;prace se soubory v tapce
;test symbol shiftu, nema cenu volat druhou ROM
;(nc=stisteno)
		ld	a,127
		in	a,(254)
		rra
		rra
		jr	nc,SETCURS
		ld	a,(hl)
		inc	hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		or	a
		jr	nz,ENOHDR
;pro flagbyte=0 jeste test delky (hlavicka)
		ex	de,hl
		ld	bc,17
		sbc	hl,bc
		jp	z,VYBERSM
		add	hl,bc
		ex	de,hl
;co s rozsirenymi bloky u TZX?
ENOHDR	ld	a,(hl)
		cp	$10
		jp	nz,VYBERSM	;zatim nic
		inc	hl			;LBA
;obrazky
	ifdef WITH_SCR
		ex	de,hl
		ld	bc,6144
		sbc	hl,bc		;nc od or a
		jr	nz,TAPIC2
		ld	a,7*8
		push	de
		push	bc
		rst	40
		defw	ATRIB
		pop	bc
		pop	hl
		jr	TAPICLD

TAPIC2	ld	bc,6912-6144
		or	a
		sbc	hl,bc
		ex	hl,de
		jr	nz,NOTAPIC
		ld	bc,6912
TAPICLD	push	bc
		push	hl
		rst	40
		defw	CAINIT
		pop	hl
		inc	hl		;preskoceni LBA
		inc	hl
		inc	hl
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		rst	40
		defw	CASEEK
		jp	SCRSPOL2
		
	endif	;WITH_SCR

NOTAPIC
;FIXME! sem pridat obsluhu dalsich souboru
		jp	VYBERSM

;nastaveni load cursoru a navrat do NMI menu
SETCURS	ld	(TAPCURS),de
		ret

LEAVETAP
		xor	a
		ld	(TAPACT),a
;obnov dat. struktury disku
		rst	40
		defw	GETISO1
;FIXME! osetreni chyby
		ret	c
		ld	hl,(ACTSDIR)
		dec	hl
;pokud se jedna o 1 sektor adr.
		ld	a,l
		or	h
		ld	hl,BUFFER
		jr	nz,LVTAP2
;preskoc prvni polozku
		ld	e,(hl)
		ld	d,0
		add	hl,de
LVTAP2	rst	40
		defw	GETISO2
		ld	a,(POZBAK)
		ld	(POZICE),a
		ld	hl,(VYPBAK)
		ld	(VYPIS),hl
		ld	a,4*8
		ld	(KURCOL),a
		jp	AGAIN

ENTER2	bit	1,(ix+25)
		jr	z,NOTDIR
;prochazeni adresaru
		ld	de,LBADISK
		ld	bc,7
		add	hl,bc
		ld	c,3
		ldir
		xor	a
		ld	(DISKACT),a
		jp	AGAIN
NOTDIR
	ifdef WITH_SCR
;detekce obrazku
		ld	a,(ix+12)
		or	(ix+13)
		jp	nz,NOTASCR
		ex	de,hl
		ld	l,(ix+10)
		ld	h,(ix+11)
		ld	bc,6144
		or	a
		sbc	hl,bc
		add	hl,bc
		jr	nz,NOTMSCR
;asi je to obrazek bez atributu
		ld	a,7*8
		push	de
		push	bc
		rst	40
		defw	ATRIB
		pop	bc
		pop	hl
;v hl adresa polozky
SCRSPOL	push	bc
		ld	de,7
		add	hl,de
		rst	40
		defw	CAINIT
SCRSPOL2	pop	bc
		ld	de,16384
		rst	40
		defw	CAREAD
;osetreni chyby pri cteni?
		rst	40
		defw	GUESBORD
SCRWTK
;pockej na stisk libovol. klav.
		rst	40
		defw	INKEYS		;cekme na klavesu
		jp	NEXTPG

NOTMSCR	ld	b,6912/256	;c=0
		or	a
		sbc	hl,bc
		ex	de,hl
		jr	nz,NOTASCR
;asi to je barevny obrazek
;v hl adresa polozky
		jr	SCRSPOL
	endif	;WITH_SCR

NOTASCR
;zjisteni pripony
		ld	de,32
		add	hl,de
;uchovej si adresu jmena
		ld	d,h
		ld	e,l
;najdi tecku (pripona)
		ld	c,(hl)
		ld	b,0
		add	hl,bc
		ld	b,c
FINDOT	ld	a,(hl)
		cp	'.'
		jr	z,ISDOT
		dec	hl
		djnz	FINDOT
;soubor nema tecku (neni prip.)
		jp	VYBERSM

ISDOT	inc	hl
;adresa celeho jmena na zasob.
		push	de
		ld	de,EXTTAP
		call	TESTPRIP
		pop	de
		jp	nz,NENITAP
;obsluha tapky
		call	TAPEPREP

;vygenerovani struktury pro virtualni adresar (obsah pasky)
;popis viz MKTZXIND
MKTAPIND	call	MKTISPC			;test mista
		jr	nc,TAPFAIL
		call	MKTILEN			;test konce souboru
;tady s tim neco udelat - nejlepe vypsat
		jp	z,TAPBROWS
;delka bloku
		call	CARDONE
		jr	c,TAPFAIL2
		ld	c,a
		call	CARDONE
		jr	c,TAPFAIL2
		ld	b,a
;test na nulovou delku bloku (maji nektere tapky)
		or	c
;povazuj to za uspesny konec
		jp	z,TAPBROWS
;odecti delku bloku od delky tapky
		push	de
;zapocitej i 2 B delky
		inc	bc
		inc	bc
		call	TLSUB16
		dec	bc
		dec	bc
		pop	de
;flagbyte
		call	CARDONE
		jr	c,TAPFAIL2
;pridej polozku do indexu
		ld	(ix+0),e
		ld	(ix+1),d
		inc	ix
		inc	ix
;uloz flag
		ld	(de),a
		inc	de
;sniz delku bloku o flag a crc
		dec	bc
;pro pozdejsi seek nebo read
		push	bc
;podle flagu hlav/telo
		push	af
		dec	bc
		ex	de,hl
		ld	(hl),c
		inc	hl
		ld	(hl),b
		inc	hl
		ex	de,hl
		pop	af
		or	a
		jr	nz,TAPBODY
		ld	hl,17
		or	a
		sbc	hl,bc
		jr	nz,TAPBODY
;je to hlavicka
;precti hlavicku a crc (crc ignorovano a je zahozeno)
		pop	bc
;BC=18 (pro platnou hlavicku)
		rst	40
		defw	CAREAD
		jr	c,TAPFAIL2
;zahod crc bloku
		dec	de
		jp	MKTAPIND

;chyba tapky (chyba formatu nebo pri cteni)
TAPFAIL2	ld	a,3*8
		defb	33
;chyba tapky (nevejde se), nastav zluty kurzor
TAPFAIL	ld	a,6*8
		jp	BROWSTR

TAPBODY
;uchovej lba nacteneho sektoru ale je to cislo dalsiho sektoru takze musis snizit o 1
		call	DECLBA
		ld	(hl),$10
		inc	hl
		ld	(hl),a
		inc	hl
		ld	(hl),d
		inc	hl
		ld	(hl),e
		inc	hl
		ex	de,hl
;a pozici v sektoru
		ld	hl,(CACHEKUR)
		ld	bc,CACHE
		or	a
		sbc	hl,bc
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
;		ex	de,hl
		pop	bc
;		push	de
		push	hl
		rst	40
		defw	CASEEK
		pop	de
		jr	c,TAPFAIL2
		jp	MKTAPIND

;vykona potrebne kroky pro inicializovani prace s TAP nebo TZX
TAPEPREP	push	de
;zazalohuj aktualni pozici vypisu a kurzoru
		ld	a,(POZICE)
		ld	(POZBAK),a
		ld	hl,(VYPIS)
		ld	(VYPBAK),hl
;prenes jmeno
		ld	hl,TAPNAME
		push	hl
		ld	bc,31
		ld	a,32
		rst	40
		defw	FILLBYTE
		pop	de
		pop	hl
		ld	c,(hl)
		ld	b,0
		inc	hl
;neprenasej cislo verze souboru (oddelene strednikem)
SEMICOL	ld	a,(hl)
		cp	';'
		jr	z,NOSEMIC
		ldi
		jp	pe,SEMICOL
NOSEMIC
;v ix adresa cele polozky
		ld	a,2*8
		ld	(KURCOL),a
;priznak: pracujem s tapkou
		ld	(TAPACT),a
		call	KURZOR

;schovej si delku tapky 2x (jednou pro sledovani konce a podruhe pro vypis v NMI menu)
		push	ix
		pop	hl
		ld	bc,7
		add	hl,bc
		push	hl
		rst	40
		defw	CAINIT
		pop	hl
		ld	bc,3
		add	hl,bc
		inc	bc
		ld	de,TAPLEN2
		push	hl
		ldir
		pop	hl
		ld	c,4
		ldir

;inicalizuj buffer a index (oboje se bude tvorit znovu)
		ld	hl,BUFFER
		ld	bc,4095
		xor	a
		rst	40
		defw	FILLBYTE
		ld	hl,INDEX
		ld	bc,588-1
		rst	40
		defw	FILLBYTE

		ld	ix,INDEX+2
		ld	de,BUFFER
;udelej misto pro ".."
		ld	(ix+0),255
		ld	(ix+1),255
		inc	ix
		inc	ix
;load-cursor na prvni polozku
		ld	(TAPCURS),ix
		ret

;zjisti, jestli neni moc souboru v indexu a bufferu
;nc - dalsi polozka se uz nevejde
MKTISPC	push	ix
		pop	hl
		ld	bc,INDEX+588-2
		or	a
		sbc	hl,bc
		ret	nc
;neprelezem pres konec bufferu?
		ex	de,hl
		ld	bc,BUFFER+4096-18
;fixne na hlavicku, takze telo by se mozna jeste veslo, ale test by byl slozitejsi
		or	a
		sbc	hl,bc
		add	hl,bc
		ex	de,hl
		ret

;zjisti, jestli uz nejsme na konci tapky (delka = 0)
;z-delka uz je 0
MKTILEN	ld	hl,TAPLEN
		ld	a,(hl)
		inc	hl
		or	(hl)
		inc	hl
		or	(hl)
		inc	hl
		or	(hl)
		ret

;odecte od delky tapky/tzx BC bajtu
TLSUB16	ld	de,0
;odecte od delky tapky/tzx DEBC bajtu
TLSUB	ld	hl,(TAPLEN)
		or	a
		sbc	hl,bc
		ld	(TAPLEN),hl
		ld	hl,(TAPLEN+2)
		sbc	hl,de
		ld	(TAPLEN+2),hl
		ret

;vrati v ADE LBA aktualniho sektoru (ukazatel uz je na dalsim, proto -1)
;vstup DE vraci jako HL!!!
DECLBA	push	de
		ld	hl,CACHELBA
		ld	a,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	e,(hl)
		ex	de,hl
		ld	de,1
		or	a
		sbc	hl,de
		sbc	a,0
		pop	de
		ex	de,hl
		ret

NENITAP
		push	de
		ld	de,EXTTZX
		call	TESTPRIP
		pop	de
		jp	nz,NENITZX
;obsluha tzx
		call	TAPEPREP
;test "magic" sekvence, je az tady, protoze v TAPEPREP je inicializace
;ale pokud magic nesedi, musi se to vsechno vratit :(
		ld	bc,10			;verze (9-10) nas nezajima
;		ld	de,BUFFER			;nastaveno z TAPEPREP
		push	de
		rst	40
		defw	CAREAD
		pop	de
		jp	c,TAPFAIL2
		ld	b,8
		ld	hl,TZXMAGIC
		call	STRNCMP
		jp	nz,TAPFAIL2
;je treba odecist z delky tapky 10B "magic"
		ld	bc,10
		call	TLSUB16
		ld	de,BUFFER			;lepsi nez porad pushovat
		ld	a,4*8			;"all ok"
		ld	(KURCOL),a

;0. flagbyte, 0=hlavicka, 1-255=blok dat
;1-2. delka bloku
;kdyz hlavicka tak nasleduje 17 bajtu hlavicky
;kdyz blok dat tak (obvykle)
;3. typ dat, $10 std. blok, viz. TZX
;4-6. LBA pocatecniho sektoru
;7-8. pozice v sektoru (posun od zacatku)

MKTZXIND	call	MKTISPC			;test mista
		jp	nc,TAPFAIL
		call	MKTILEN			;test konce souboru
;tady s tim neco udelat - nejlepe vypsat
		jp	z,TPBRSNC
;id bloku
		call	CARDONE
		jp	c,TAPFAIL2
		bit	7,a
		jr	z,MKTZXI2
		xor	a
MKTZXI2	ld	(TZXBLKID),a
		ld	(TZXBPOS),de
		ld	l,a
		ld	h,0
		ld	e,l
		ld	d,h
		ld	b,h				;B=0
		add	hl,hl			;x3
		add	hl,de
		ld	de,TZXLENS
		add	hl,de
		ld	a,(hl)
		inc	hl
		or	a
		ld	c,a
		jr	nz,TZXDTBLK
		ld	a,(hl)
		inc	c				;BC=1
		call	TLSUB16			;pro odecteni delky ID bloku
		dec	c
;po navratu je DE=0, to potrebujem, ted DEBC=0
;pokracuj spolecnou casti, lseek by mel nulovou delku ustat
		jr	TZXFINLEN

TZXDTBLK	push	hl
;telo bloku (tzx hlavicka), v BC jeji delka + 1 na id bloku
		inc	bc
		call	TLSUB16
		dec	bc
		ld	de,TZXBUFF
		rst	40
		defw	CAREAD
		pop	hl
		jp	c,TAPFAIL2
		ld	a,(hl)
		push	af
		inc	hl
		ld	l,(hl)
		ld	h,TZXBUFF/256
		ld	c,0
		ld	b,c
		ld	e,c
		ld	d,c
		and	%00001111
		jr	z,TZXGOTLEN
		ld	c,(hl)
		dec	a
		jr	z,TZXGOTLEN
		inc	hl
		ld	b,(hl)
		dec	a
		jr	z,TZXGOTLEN
		inc	hl
		ld	e,(hl)
		dec	a
		jr	z,TZXGOTLEN
		inc	hl
		ld	d,(hl)
TZXGOTLEN	pop	af
;nasobeni
		bit	7,a
		jr	z,TZXFINLEN
;dvema
		push	bc
		pop	iy
		ld	l,e
		ld	h,d
		add	iy,bc
		adc	hl,de
		bit	6,a
		jr	z,TZXMVLEN
;tremi (musi projit i casti 'dvema')
		add	iy,bc
		adc	hl,de
TZXMVLEN	ld	e,l
		ld	d,h
		push	iy
		pop	bc
TZXFINLEN	bit	5,a
		jr	z,TZXSTOR
		ld	a,3*8
		ld	(KURCOL),a
TZXSTOR	call	TLSUB
		ld	a,(TZXBLKID)
		ld	hl,(TZXBPOS)
		ld	(ix+0),l
		ld	(ix+1),h
		inc	ix
		inc	ix
;pokud se jedna o standardni blok je treba ho prohledat a nacist pripadnou hlavicku
		cp	$10
		jr	nz,TZXSTOR2
;fixme - spojit s MKTAPIND
;flagbyte
		call	CARDONE
		jp	c,TAPFAIL2
		dec	bc				;flag
		dec	bc				;crc
		ld	(hl),a
		inc	hl
		ld	(hl),c
		inc	hl
		ld	(hl),b
		inc	hl
		inc	bc				;pro seek/read
;podle flagu hlav/telo
		or	a
		ld	a,$10
		jr	nz,TZXBODY2
		push	hl
		ld	hl,18			;BC je o 1 vetsi
		sbc	hl,bc			;NC snad od or a
		pop	hl
		jr	nz,TZXBODY2
		ex	de,hl
		rst	40
		defw	CAREAD
		jp	c,TAPFAIL2
;zahod crc bloku
		dec	de
		jp	MKTZXIND

TZXSTOR2	ld	(hl),255			;body
TZXBODY	inc	hl
		ld	(hl),c			;z delky pouze nizsich 16b
		inc	hl
		ld	(hl),b
		inc	hl
TZXBODY2	ld	(hl),a
		inc	hl
		push	de
		push	bc
		ex	de,hl
		call	DECLBA
;LBA sektrou (fixme - spojit s MKTAPIND)
		ld	(hl),a
		inc	hl
		ld	(hl),d
		inc	hl
		ld	(hl),e
		inc	hl
		ex	de,hl
;a pozici v sektoru
		ld	hl,(CACHEKUR)
		ld	bc,CACHE
		or	a
		sbc	hl,bc
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
;FIXME - tady pridat ulozeni dalsich dat z hlavicky pro ID 35 (custom info)
		pop	bc
		pop	de
		push	hl
		rst	40
		defw	CALSEEK
		pop	de
		jp	c,TAPFAIL2
		jp	MKTZXIND


NENITZX
	ifdef WITH_POK
		ld	de,EXTPOK
		call	TESTPRIP
		jp	nz,NENIPOK
		push	ix
		pop	hl
;v hl adresa polozky
		ld	de,7
		add	hl,de
		ex	de,hl			;lba souboru do de
;jeden 2048B sektor do CACHE
		ld	hl,CACHE
		push	hl
		rst	40
		defw	RDWR1SEC
;bylo by dobre zneplatnit data o poke?
;rozebrani .pok souboru
		pop	hl
		ld	ix,POKTAB
		ld	de,POKDATA
		ld	a,25				;max pocet "traineru" + 1
		ex	af,af'
PKSM1	ld	a,(hl)			;prvni znak na radce urcuje obsah
		inc	hl
		cp	'M'
		jr	z,PKLNDTA
		cp	'Z'
		jr	z,PKLNDTA			;'M' a 'Z' je mi jedno
		cp	'N'
		jr	nz,PKEOF			;'Y' nebo cokoliv jineho->konec
;vlezem se jeste do vyhrazene pameti?
		ex	af,af'
		dec	a
		jr	z,PKEOF			;moc traineru
		ex	af,af'
		ex	de,hl
		ld	bc,POKEND-35+1		;35=28+1+5+1, +1 kuli nc
		or	a
		sbc	hl,bc
		jr	nc,PKEOF			;nevejdem
		add	hl,bc
		ex	de,hl
		ld	(ix+0),e
		ld	(ix+1),d
		inc	ix
		inc	ix
;jmeno pro "trainer"
		ld	b,28
PKNME1	ld	a,(hl)
		cp	' '
		jr	nc,PKNME2
		dec	hl				;korekce, neposouvej se na dalsi znak
		ld	a,' '
PKNME2	ld	(de),a
		inc	hl
		inc	de
		djnz	PKNME1
		push	de
		pop	iy				;adresa statusu
		inc	de
PKSM2	xor	a
		ld	(de),a			;konec seznamu hodnot
		inc	de
PKFNDLN	ld	a,(hl)			;najdi novy radek
		inc	hl
		cp	10
		jr	nz,PKFNDLN
		jr	PKSM1

;data pro "trainer"
PKLNDTA	dec	de
;vlezem se jeste do vyhrazene pameti?
		ex	de,hl
		ld	bc,POKEND-6+1		;6=5+1, +1 kuli nc
		or	a
		sbc	hl,bc
		jr	nc,PKEOF			;nevejdem
		add	hl,bc
		ex	de,hl
		call	ATOI				;page
		ld	a,c
		or	64+16
		ld	(de),a
		inc	de
		call	ATOI				;address
		ex	de,hl
		ld	(hl),c
		inc	hl
		ld	(hl),b
		inc	hl
		ex	de,hl
		call	ATOI				;value + ask
		ld	(iy+0),b			;bud 0 nebo 1 (ask)
		ex	de,hl
		ld	(hl),c
		inc	hl
		ex	de,hl
		call	ATOI				;original value
		ld	a,c
		ld	(de),a
		inc	de
		jr	PKSM2

;konec .pok souboru
PKEOF	xor	a
		ld	(ix+0),a
		ld	(ix+1),a
		ld	(POKCUR),a
		call	POKEMAN			;muzem volat i z nmi menu
		jp	NEXTPG

;zjisteni aktualniho stavu
POKEMAN	rst	40
		defw	SCRINIT2
		ld	hl,POKTAB
		ld	a,(hl)
		inc	hl
		cp	(hl)
		dec	hl
		jp	z,POKADD			;tabulka prazdna, rucni vstup
POKEMSM	ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	a,e
		or	d
		jr	z,PKSHOW
		ex	de,hl
		ld	bc,28
		add	hl,bc
		ld	a,(hl)
		and	1
		or	4*8+2			;init stavu (green + active)
		ld	(hl),a
		push	hl
		pop	ix
POKEMAN3	inc	hl
		ld	a,(hl)
		or	a
		ex	hl,de
		jr	z,POKEMSM
		ex	de,hl
		bit	3,a
		jr	nz,POKEMAN2
		out	(253),a			;128k page
POKEMAN2	inc	hl
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		ld	a,(bc)
		inc	hl
		bit	0,(ix+0)
		jr	z,POKEMAN6
;vyptavaci hodnota, pouzij aktualni stav pameti
;dalsi testy pak dopadaji porad stejne, ale bylo by slozitejsi je preskakovat
		ld	(hl),a
POKEMAN6	ld	b,(hl)			;poke
		inc	hl
		ld	c,(hl)			;original
		ex	af,af'
;zjisteni barvy kurzoru
;green - urcite ok (orig. hodnota znama a v pameti je poke nebo orig. hodnota)
;yellow - mozna ok (orig hodnota neni znama)
;red - urcite spatne (orig. hodnota znama a v pameti neni ani poke ani orig. hodnota)
		ld	a,c
		or	a
		jr	nz,POKEMAN5
		set	4,(ix+0)			;yellow (neznamo)
POKEMAN5	ex	af,af'
		cp	b
		jr	z,POKEMAN3		;aktivni, tj. nemuze byt red
		res	1,(ix+0)			;not active
POKEMAN4	cp	c
		jr	z,POKEMAN3		;v pameti orginal
		ld	a,c
		or	a
		jr	z,POKEMAN3		;nevime, mozna dobre
;nerovna se ani znamemu originalu, ani poke, spatne -> konec
;nech pouze "ask" bit
		ld	a,(ix+0)
		and	1
		or	2*8				;red
		ld	(ix+0),a
		ex	de,hl
		jr	POKEMSM

;zobrazeni aktualnich traineru
PKSHOW	rst	40
		defw	SCRINIT2
		ld	hl,POKTAB
PKLST1	ld	e,(hl)
		inc	hl	
		ld	d,(hl)
		inc	hl
		ld	a,e
		or	d
		jr	z,PKENDLST
		ex	de,hl
		ld	b,28
		rst	40
		defw	PRINTB
		ld	a,32
		rst	16
		ld	a,(hl)
		bit	0,a
		jr	z,PKLST2
		inc	hl
		inc	hl
		inc	hl
		inc	hl
		ld	l,(hl)
		push	de
		rst	40
		defw	PRINTL3
		pop	hl
		jr	PKLST4

PKLST2	ld	hl,TXTNO
		bit	1,a
		jr	z,PKLST3
		inc	hl
		inc	hl
PKLST3	call	PRINT128R
		ex	de,hl
PKLST4	ld	a,13
		rst	16
		jr	PKLST1

;interakce s uzivatelem
PKENDLST	ld	hl,POKCUR
PKENDLST2	ld	a,(hl)
		add	a,a
		ld	c,a
		ld	b,0
		ex	de,hl
		ld	hl,POKTAB
		add	hl,bc
		ld	a,(hl)
		inc	hl
		ld	h,(hl)
		ld	l,a
		ld	c,28				;b=0
		add	hl,bc
		ld	a,(hl)			;stav
		and	%00111000			;ponech pouze barvu
		ex	af,af'
		ex	de,hl
		ld	a,(hl)
		call	KURZORA
POKESM	push	hl
		rst	40
		defw	INKEYSRAW
		pop	hl
		cp	'7'
		jr	z,POKEUP
;		cp	11
;		jr	z,POKEUP
		cp	'6'
		jr	z,POKEDOWN
;		cp	10
;		jr	z,POKEDOWN
		cp	'5'
		jr	z,POKEPGUP
;		cp	8
;		jr	z,POKEPGUP
		cp	'8'
		jr	z,POKEPGDW
;		cp	9
;		jr	z,POKEPGDW
		cp	13
		jr	z,POKEENT
;		or	32				;mala pismena
		cp	'a'
		jp	z,POKADD
		cp	'd'
		jp	z,POKDEL
		cp	'c'
		jp	z,POKCLEAR
		cp	' '
		jr	nz,POKESM
		ret

POKEUP	ld	a,(hl)
		or	a
		jr	z,POKESM
		dec	(hl)
		jr	PKENDLST2

POKEDOWN	call	FINDPEND
		jr	z,POKESM
		inc	(hl)
		jr	PKENDLST2

POKEPGUP	ld	(hl),0
		jr	PKENDLST2

POKEPGDW	call	FINDPEND
		jr	z,PKENDLST2
		inc	(hl)
		jr	POKEPGDW

POKEENT	call	FINDPEND
		ld	a,(hl)
		ld	iyu,a			;pozice inputu
		ld	h,(ix-1)
		ld	l,(ix-2)
		ld	c,28				;b=0
		add	hl,bc
		ld	a,(hl)
		bit	0,a
		jr	z,POKEENT2
		push	hl
		pop	ix
;je treba nastavit barvy pro tisk
		ld	a,16
		rst	16
		xor	a
		rst	16
		ld	a,17
		rst	16
		ld	a,(hl)
		rra
		rra
		rra
		and	7
		rst	16
		ld	hl,INPBUFF
		ld	(hl),' '+128
		inc	hl
		push	hl
		ld	b,3
		ld	a,32
POKEENT4	ld	(hl),a
		inc	hl
		djnz	POKEENT4
		ld	(hl),' '+128		;znacka konce
		pop	bc
		ld	iyl,0			;nepis nevyzname nuly
		ld	l,(ix+5)			;nabizime original value
		ld	h,0
		rst	40
		defw	STOR8DC
		ld	iyl,28
POKEENT7	ld	hl,0
POKEENT5	rst	40
		defw	INPUT
		ld	hl,0				;zruseni blikani kurzoru
		ld	(IKURPOS),hl
		jp	c,PKSHOW			;stisteno 'edit'
		inc	de
		ex	de,hl
		call	ATOI
		ld	a,(hl)
		cp	' '
		jr	z,POKEENT3
		bit	7,a
		call	z,BEEPR
		jr	z,POKEENT5
POKEENT3	ld	a,b
		or	a
		call	nz,BEEPR
		jr	nz,POKEENT7
;v C je hodnota
		ld	(ix+4),c
		ld	a,(ix+1)
		bit	3,a
		jr	nz,POKEENT6
		out	(253),a
POKEENT6	ld	l,(ix+2)
		ld	h,(ix+3)
		ld	(hl),c
		jp	PKSHOW

;on/of
POKEENT2	xor	2				;prohozeni on/off
		ld	c,a				;zapamatujem
		ld	(hl),a
;nastaveni hodnot do pameti
SETPK1	inc	hl
		ld	a,(hl)
		or	a
		jp	z,PKSHOW
		bit	3,a
		jr	nz,SETPK2
		out	(253),a			;128k page
SETPK2	inc	hl
		ld	e,(hl)
		inc	hl
		ld	d,(hl)
		inc	hl
		ld	b,(hl)			;poke
		inc	hl
		ld	a,(hl)			;orig
		bit	1,c
		jr	z,SETPK3
		ld	a,b
SETPK3	ld	(de),a
		jr	SETPK1

;kompletni smazani vsech cheatu v pameti
POKCLEAR	ld	hl,0
		ld	(POKTAB),hl
		rst	40
		defw	SCRINIT2
		jr	POKADD

;zruseni posledniho cheatu
POKDEL	ld	hl,POKTAB
		ld	b,h
		ld	c,l
POKDEL2	ld	a,(hl)
		inc	hl
		or	(hl)
		inc	hl
		jr	nz,POKDEL2
		dec	hl
		dec	hl
		xor	a				;0+nc
		dec	hl
		ld	(hl),a
		dec	hl
		ld	(hl),a
		ld	(POKCUR),a		;kurzor na zacatek at s nim neni problem
;jsme uplne na zacatku?
		sbc	hl,bc
		jp	nz,PKSHOW			;ne
;ano, musime neco pridat, pokracujem v POKADD
		rst	40
		defw	SCRINIT2
;sem nic nepridavat!!!

;rucni pridani cheatu
POKADD	ld	hl,POKTAB-1
		ld	bc,POKDATA
POKADD2	ld	d,b				;potrebujem minulou hodnotu
		ld	e,c
		inc	hl
		ld	c,(hl)
		inc	hl
		ld	b,(hl)
		ld	a,b
		or	c
		jr	nz,POKADD2
		dec	hl
;je jeste misto?
;(staci na pocet, data by se mela vejit vzdy)
		ld	bc,POKTAB+48		;2*24
		sbc	hl,bc			;nc je od or c
		add	hl,bc
		call	z,BEEPR
		jp	z,PKENDLST		;nemuze se stat kdyz je prazdno
;v de adresa poslednich dat, musime najit konec
;ale jen pripade, ze to neni uplny zacatek
		ld	bc,POKTAB
		push	bc
		or	a
		sbc	hl,bc
		add	hl,bc
		jr	z,POKADD7
		ex	de,hl
		ld	bc,30			;posun na page
		add	hl,bc
		ld	c,5				;b=0
POKADD3	ld	a,(hl)
		add	hl,bc
		or	a
		jr	nz,POKADD3
		sbc	hl,bc			;nc od or a
		ex	de,hl
;mame adresu kam davat data
POKADD7	pop	bc
		push	hl				;pozice v POKTAB
		push	de				;adr. dat
		pop	ix
;vstup od uzivatele
		sbc	hl,bc			;nc odminula
		ld	a,l				;nebude vic jak 50
		srl	a				;deleni dvema
		ld	iyu,a
		ld	iyl,0
		ld	hl,MANTEMP
		ld	de,INPBUFF
		push	de
		ld	bc,MTEND-MANTEMP
		ldir
		pop	hl
POKADD4	rst	40
		defw	INPUT
		ld	hl,0				;zruseni blikani kurzoru
		ld	(IKURPOS),hl
		jp	c,POKADDEND		;stisteno 'edit'
		inc	de
		ex	de,hl
		call	ATOI
		ld	a,(hl)
		cp	' '
		dec	hl				;korekce input kurzoru
		call	nz,BEEPR
		jr	nz,POKADD4
		ld	a,b
		or	a
		call	nz,BEEPR
		jr	nz,POKADD4
		ld	a,c
		cp	9				;max 8
		call	nc,BEEPR
		jr	nc,POKADD4
		or	64+16
		ld	(ix+29),a
		inc	hl				;korekce input kurzoru
		call	ATOI
		ld	a,(hl)
		cp	' '
		dec	hl				;korekce input kurzoru
		call	nz,BEEPR
		jr	nz,POKADD4
		ex	de,hl
		ld	l,c
		ld	h,b
		ld	bc,NMISTACK		;chranime nasi RAM i stack
		or	a
		sbc	hl,bc
		add	hl,bc
		ex	de,hl
		call	c,BEEPR
		jr	c,POKADD4
		ld	(ix+30),e
		ld	(ix+31),d
		inc	hl				;korekce input kurzoru
		call	ATOI
		ld	a,(hl)
		cp	' '
		jr	z,POKADD5
		dec	hl				;korekce input kurzoru
		bit	7,a
		call	z,BEEPR
		jr	z,POKADD4
POKADD5	ld	a,b
		or	a
		call	nz,BEEPR
		jr	nz,POKADD4
		ld	(ix+32),c
		ex	de,hl			;poke adresa
		ld	a,(ix+29)
		bit	3,a
		jr	nz,POKADD6
		out	(253),a
POKADD6	ld	a,(hl)
		ld	(ix+33),a
		ld	(ix+34),0			;koncova znacka
		ld	(ix+28),4*8		;no ask, no active, green
;slozime "jmeno"
		push	ix
		pop	hl
		push	hl
		push	hl
		ld	c,27				;v b je 0
		ld	a,' '
		rst	40
		defw	FILLBYTE
		pop	bc
		inc	bc
		ld	a,(ix+29)
		and	15
		ld	l,a
		ld	h,0
		ld	iyl,0
		rst	40
		defw	STOR6DC
		ld	a,':'
		ld	(bc),a
		inc	bc
		ld	l,(ix+30)
		ld	h,(ix+31)
		rst	40
		defw	STOR16DC
		ld	a,','
		ld	(bc),a
		inc	bc
		ld	l,(ix+32)			;v h by mela byt 0
		rst	40
		defw	STOR8DC
		inc	bc				;mezera
		ld	a,'('
		ld	(bc),a
		inc	bc
		ld	l,(ix+33)			;v h by mela byt 0
		rst	40
		defw	STOR8DC
		ld	a,')'
		ld	(bc),a
		pop	bc
		pop	hl
		ld	(hl),c
		inc	hl
		ld	(hl),b
		inc	hl
		xor	a
		ld	(hl),a			;koncova znacka
		inc	hl
		ld	(hl),a
		jp	PKSHOW			;finito

POKADDEND	pop	hl
		ld	bc,POKTAB
		or	a
		sbc	hl,bc
		ret	z				;jsme na zacatku, navrat odkud volano
		jp	PKSHOW			;jinak smyckujem

;test jestli je dalsi pokpolozka platna
;nz=platna
FINDPEND	ld	a,(hl)
		add	a,a
		ld	c,a
		ld	b,0
		ld	ix,POKTAB+2		;next item
		add	ix,bc
		ld	a,(ix+0)
		or	(ix+1)
		ret

;precte cislo v textove podobe z adresy HL
;vysledek v BC, na (HL) prvni neplatny znak
;vynechava mezery na zacatku
;a konci na prvnim neciselnem znaku
ATOI		ld	a,(hl)
		inc	hl
		cp	' '
		jr	z,ATOI
		dec	hl
		ld	bc,0
ATOI2	ld	a,(hl)
		sub	'0'
		ret	c
		cp	10
		ret	nc
		inc	hl
		push	hl
		ld	h,b
		ld	l,c
		add	hl,hl	;2x
		add	hl,hl	;4x
		add	hl,hl	;8x
		add	hl,bc	;9x
		add	hl,bc	;10x
		ld	b,0
		ld	c,a
		add	hl,bc
		ld	b,h
		ld	c,l
		pop	hl
		jr	ATOI2

;musi byt takhle zasebou a TXTNO jen 2 byte
TXTNO	defb	'N', 'O'+128
TXTYES	defb	"YE", 'S'+128

;predloha pro rucne zadany poke
MANTEMP	defb	' '+128,"P ADDRS VAL",' '+128
MTEND

	endif ;WITH_POK

NENIPOK
	ifdef WITH_SNA
;spousteni .SNA
		ld	de,EXTSNA
		call	TESTPRIP
		jp	nz,NENISNA
;obsluha snapu .sna
;test delky (neni dokonaly, ale co je?)
		ld	e,(ix+10)
		ld	d,(ix+11)
		ld	a,(ix+12)
		ld	b,a
		or	(ix+13)
		jr	z,SNA48
		dec	b
		dec	b
		jp	nz,NENISNA		;2*64 KB
		ex	de,hl
		ld	bc,SNALEN2-131072	;31
		sbc	hl,bc			;carry je vynulovane z or (ix+13)
		jr	z,SNA128
		ld	bc,SNALEN3-SNALEN2	;16384
		or	a
		sbc	hl,bc
		ex	de,hl
		jp	nz,NENISNA
;128K SNA
SNA128	call	SNAPINIT
		call	IS48KMODE
;preskocime 48K cast
		ld	bc,SNALEN1
		rst	40
		defw	CASEEK
		ret	c
;nasledujici ctyri cteni jedou z cache, nemusi byt test na chybu
		call	CARDONE			;PC(L)
		ld	l,a
		call	CARDONE			;PC(H)
		ld	h,a
		ld	(SNAPC),hl
		call	CARDONE			;port 7FFD
		ld	(SNAPAGE),a
		and	7
		or	64+16			;pro porovnavani
		ld	c,a
		call	CARDONE			;trtdos ROM (ignored)
;nasleduji stranky ve vzestupnem poradi, 2 a 5 vynechane, aktualne pristrankovana taky
		ld	b,64+16
SNA128_2	ld	a,b
		cp	64+16+2
		jr	z,SNA128_3
		cp	64+16+5
		jr	z,SNA128_3
		cp	c
		jr	z,SNA128_3
		out	(253),a
		push	bc
		ld	de,49152
		ld	bc,16384
		rst	40
		defw	CAREAD
		pop	bc
		ret	c
SNA128_3	inc	b
		bit	3,b				;uz mame vsechny stranky?
		jr	z,SNA128_2
;mame 128K stranky, zbytek nasosnem jako 48K verzi
		ld	a,(SNAPAGE)
		or	64				;fixme - vynucovat BASIC ROM (or 16)?
		out	(253),a
		call	SNAPINIT2
		call	SNAALL
		ret	c
;onanie s PC ktery uz neni na zasobniku
		ld	bc,(SNAPC)		;berem ze sosaci stranky a tlacime do spousteci
		call	INTSYNC			;novy zasobnik
		ld	hl,(SNASTART+23)
;emulace push (potrebujem zachovat sp)
		dec	hl
		ld	(hl),b
		dec	hl
		ld	(hl),c
		ld	(SNASTART+23),hl
		jr	SNA48_2

;48K SNA
SNA48	ld	bc,SNALEN1
		ex	hl,de
		or	a
		sbc	hl,bc
		ex	hl,de
		jp	nz,NENISNA
		call	SNAPINIT
		call	SNAALL
		ret	c
		call	INTSYNC
;vytvor si relativni skok podle
;stavu preruseni
SNA48_2	ld	a,(SNASTART+19)
		bit	2,a
		ld	hl,EIROM
		jr	nz,SNAEI
		inc	hl
SNAEI	ld	(SNARUN+1),hl
		ld	hl,SNASTART+26
		ld	a,(hl)
		out	(254),a
		dec	hl
		ld	a,(hl)
		im	0
		or	a
		jr	z,IMSNA
		im	1
		dec	a
		jr	z,IMSNA
		im	2
IMSNA	ld	hl,SNASTART
		ld	a,(hl)
		ld	i,a
		inc	hl
		ld	sp,hl
		pop	hl
		pop	de
		pop	bc
		pop	af
		exx
		ex	af,af'
		pop	hl
		pop	de
		pop	bc
		pop	iy
		pop	ix
;stejne asi bude R spatne :(
		pop	af
		ld	r,a
		pop	af
		ld	sp,(SNASTART+23)
		jp	SNARUN

;nacteni zacatku sna
SNAALL	ld	de,SNASTART
		ld	bc,SNAHDR
		call	SNAPHEAD
		ret	c
		ld	de,SNASTART+SNAHDR
		ld	bc,SNALEN1-SNAHDR
		rst	40
		defw	CAREAD
		ret
;konec prace se .sna
	endif	;WITH_SNA

NENISNA
	ifdef WITH_MFC
;spousteni .MFC
		ld	de,EXTMFC
		call	TESTPRIP
		jp	nz,NENIMFC
;obsluha snapu .mfc
		call	SNAPINIT
		ld	bc,MFCHEAD
		ld	de,MFCSTART
		call	SNAPHEAD
		ret	c
;border a verze snapu (z kopie)
		ld	hl,(SNATMP+4)		;a +5
		ld	a,l
		or	a
		call	nz,IS48KMODE		;128k test
		ld	a,h
		out	(254),a
		push	hl
		push	de
		ld	bc,512-MFCHEAD
		rst	40
		defw	CASEEK
;nemusi byt test uspesnosti,
;urcite to jede to z cache
;nacteni 48K dat
		pop	de
		ld	bc,49152
		rst	40
		defw	CAREAD
		pop	hl
		ret	c
		ld	a,l
		or	a
		jr	z,MFC48
;je to 128K snap, loadnem str.
		ld	hl,MFCPAGES
MFC128	ld	a,(hl)
		or	a
		jr	z,MFC128_2
		out	(253),a
		inc	hl
		push	hl
		ld	de,49152
		ld	bc,16384
		rst	40
		defw	CAREAD
		pop	hl
		ret	c
		jr	MFC128

MFC128_2	call	INTSYNC			;a mame novy zasobnik
		ld	hl,MFCSTART+37
		push	hl
		call	AYSOUND
		pop	hl
		dec	hl
		ld	b,255
		ld	a,(hl)
		out	(c),a
		dec	hl
;nastaveni aktualni 128 stranky
		ld	a,(hl)
;aby fungoval out na 253 (+2A)
		or	16+64
		out	(253),a
;dal uz spolecne pro 48 i 128
MFC48	call	INTSYNC			;pro 128k podruhe, ale to nevadi
;vytvor si relativni skok podle
;stavu preruseni
		ld	a,(MFCSTART+30)
		bit	2,a
		ld	hl,EIROM
		jr	nz,MFCEI
		inc	hl
MFCEI	ld	(SNARUN+1),hl
		ld	sp,MFCSTART+6
		pop	hl
		pop	de
		ld	a,d
		or	e
		jr	z,MFC_NOPC
;ulozeni startu na zas. prog.
		dec	hl
		ld	(hl),d
		dec	hl
		ld	(hl),e
		ld	(MFCSTART+6),hl
MFC_NOPC	ld	a,(MFCSTART+10)
		im	0
		or	a
		jr	z,IMMFC
		im	1
		dec	a
		jr	z,IMMFC
		im	2
IMMFC
		pop	af
		ld	i,a
		pop	hl
		pop	de
		pop	bc
		pop	af
		exx
		ex	af,af'
		pop	hl
		pop	de
		pop	bc
		pop	iy
		pop	ix
;stejne asi bude R spatne :(
		pop	af
		ld	r,a
		pop	af
		ld	sp,(MFCSTART+6)
		jp	SNARUN

MFCPAGES	defb	17+64,19+64,20+64
		defb	22+64,23+64,0
;konec prace s .mfc
	endif	;WITH_MFC

NENIMFC
	ifdef WITH_Z80
;spousteni .Z80
		ld	de,EXTZ80
		call	TESTPRIP
		jp	nz,VYBERSM
;obsluha snapu .z80
		call	SNAPINIT
;zacatek stejny ve vsech verz.
		ld	bc,Z80HDR1
		ld	de,Z80START
		call	SNAPHEAD
		ret	c
		ld	a,(SNATMP+12)
		inc	a
		jr	nz,Z80BORD
;korekce 255->1
		ld	a,2
Z80BORD	dec	a
		ld	b,a
;v B priznaky pro verzi 1.x
		rra
		and	7
		out	(254),a
		ld	hl,(SNATMP+6)
		ld	a,l
		or	h
;kdyz PC neni 0, je to verze 1
		jp	nz,VERS1
;nasleduje delka dalsich dat
		call	CARDONE
		ret	c
		ld	c,a
		call	CARDONE
		ret	c
		ld	b,a
;vsechny je nacti
		push	bc
		ld	de,Z80START+Z80HDR1+2
		ld	hl,SNATMP+Z80HDR1+2
		call	SNAPHEAD2
		pop	bc
		ret	c
;v2.x nebo 3.x+?
		ld	a,c
		ld	b,3
		cp	23
		jr	z,JETO2X
		inc	b
;zjisti verzi snapu (48/128)
JETO2X	ld	a,(SNATMP+34)
		cp	b
		jr	c,K48
;vyjimky dalsich emulatoru
;didaktik
		cp	11
		jr	z,K48
;timex
		cp	14
		jr	z,K48
		cp	128
		jr	z,K48
;je to 128k snap
		call	IS48KMODE
		ld	b,8
K128		push	bc
		call	ONEPAGE1
		pop	bc
		ret	c
		djnz	K128
		jp	RUNZ80

K48		ld	b,3
K48_2	push	bc
		call	ONEPAGE4
		pop	bc
		ret	c
		djnz	K48_2
;pro 48K ne AY ani stranka
		jp	JENV1

	else
;Z80 je posledni, pokud neni prekladan, navrat
		jp	VYBERSM
	endif	;WITH_Z80

	ifdef ANY_SNAP
;chyba pri spusteni snapu
;pouzivaji vsechny snapy
SNAERR	in	a,(167)
		rra
		rra
		rra
		rra
SNAERR2	out	(254),a
SNAERR3	jr	SNAERR3		;konecna
	endif

	ifdef WITH_Z80
;precte jednu stranku s pripadnym vynechanim nechtenych str.
ONEPAGE	call	RDPG
		ret	c
;odecti posun 128 stranek
		sub	3
		jr	c,BADPG
		cp	8
		jr	c,GOODPG
BADPG
;spatne cislo stranky, vynech ji
;test na kompresi bloku
		ld	b,d
		ld	c,e
		inc	de
		ld	a,d
		or	e
		jr	nz,BADPG2
		ld	bc,16384
;preskoc
BADPG2	rst	40
		defw	CASEEK
		ret	c
;zkus dalsi stranku
		jr	ONEPAGE

GOODPG	or	a
		ret


;precte jednu stranku pro 128k
;navrat s C kdyz chyba
ONEPAGE1	call	ONEPAGE
		ret	c
;vyuzij zrcadleni stranek
		ld	hl,49152
;aby fungoval out na 253 (+2A)
		or	64+16
		out	(253),a
		jr	Z80RDBK

;precte jednu stranku pro 48k
;navrat s C kdyz chyba
ONEPAGE4	call	ONEPAGE
		ret	c
;nastav HL podle cisla stranky
		ld	hl,32768
		dec	a
		jr	z,Z80RDBK
		ld	hl,49152
		dec	a
		jr	z,Z80RDBK
		ld	hl,16384
		cp	3
;v 48K verzi nesmi byt jine stranky
;nez 4, 5 a 8 jinak chyba
		ld	a,1
		jr	nz,SNAERR2
;spolecna cast (48/128)
;je blok komprimovan?
Z80RDBK	inc	de
		ld	a,d
		or	e
		dec	de
		jr	nz,DEPSM1
;bez komprese, prime cteni
		ex	de,hl
		ld	bc,16384
		rst	40
		defw	CAREAD
;navrat se predpoklada s HL
		ex	de,hl
		ret

DEPSM1	call	CARDONE2
		ret	c
;komprese?
		cp	$ED
		jr	z,PACK1
PACK3	ld	(hl),a
		inc	hl
DEPSM3	ld	a,e
		or	d
		jr	nz,DEPSM1
		or	a
		ret

PACK1	ld	a,e
		or	d
;jestli na konci, komprese ne
		ld	a,$ED
		jr	z,PACK3
		call	CARDONE2
		ret	c
		cp	$ED
		jr	z,PACK2
		ld	(hl),$ED
		inc	hl
		jr	PACK3

PACK2
		call	CARDONE2
		ret	c
		push	bc
		ld	b,a
		call	CARDONE2
		push	af
DEPSM2	ld	(hl),a
		inc	hl
		djnz	DEPSM2
		pop	af
		ret	c
		pop	bc
		jr	DEPSM3


;nacte hlavicku stranky
;navrat s C kdyz chyba
;v DE delka bloku
;a A cislo stranky
RDPG		call	CARDONE
		ret	c
		ld	e,a
		call	CARDONE
		ret	c
		ld	d,a
		jp	CARDONE


;zpracuje blok verze 1.x
;navrat s C kdyz chyba
DEPV1_1	call	CARDONE
		ret	c
;komprese? konec bloku?
		cp	$ED
		jr	z,PACKV1_1
PACKV1_3	ld	(hl),a
		inc	hl
		jr	DEPV1_1

PACKV1_1
		call	CARDONE
		ret	c
		cp	$ED
		jr	z,PACKV1_2
		ld	(hl),$ED
		inc	hl
		jr	PACKV1_3

PACKV1_2
		call	CARDONE
		ret	c
;konec bloku? ($ED $ED $00)
;dofufam, ze 0 taky neznamena
;256x a konec je jenom
;$00 $ED $ED $00
		or	a
;NC je taky
		ret	z
		ld	b,a
		call	CARDONE
		ret	c
DEPV1_2	ld	(hl),a
		inc	hl
		djnz	DEPV1_2
		jr	DEPV1_1

;nacteni .z80 verze 1.x
VERS1	ld	hl,16384
;komprimovany blok?
		bit	5,b
		jr	nz,V1PACK
		ex	de,hl
		ld	bc,49152
		rst	40
		defw	CAREAD
		jr	V1SPOL

V1PACK	call	DEPV1_1
V1SPOL	ret	c
		jr	JENV1

;spusteni .Z80
RUNZ80	call	INTSYNC
		ld	hl,Z80START+39
		call	AYSOUND
		ld	b,255
		ld	a,(Z80START+38)
		out	(c),a
;nastaveni aktualni 128 stranky
		ld	a,(Z80START+35)
;aby fungoval out na 253 (+2A)
		or	64				;fixme - vynucovat BASIC ROM (or 16)?
		out	(253),a
JENV1	call	INTSYNC			;pro 128k podruhe, ale to neva
		ld	a,(Z80START+27)
		or	a
		ld	hl,EIROM
		jr	nz,Z80EI
		inc	hl
Z80EI	ld	(SNARUN+1),hl
		ld	sp,Z80START+15
		pop	bc
		pop	de
		pop	hl
		exx
;A a F jsou ulozeny obracene!!!
;cteni s prohozenim A a F
		pop	bc
		dec	sp
		pop	af
		dec	sp
		ld	a,c
;az sem
		ex	af,af'
		pop	iy
		pop	ix
		ld	a,(Z80START+29)
		im	0
		and	%00000011
		jr	z,IMZ80
		im	1
		dec	a
		jr	z,IMZ80
		im	2
IMZ80	ld	hl,Z80START+10
		ld	a,(hl)
		ld	i,a
		inc	hl
		ld	a,(hl)
		inc	hl
		rla
		ld	b,a
		ld	a,(hl)
		rra
		ld	a,b
		rra
		ld	r,a
		ld	sp,Z80START
;vezmi spravny reg. PC
		ld	hl,(Z80START+6)
		ld	a,l
		or	h
		jr	nz,PC_V1
		ld	hl,(Z80START+32)
PC_V1	ex	hl,de			;s HL je to o byte kratsi
;A a F jsou ulozeny obracene!!!
;cteni s prohozenim A a F
		pop	bc
		dec	sp
		pop	af
		dec	sp
		ld	a,c
;az sem
		pop	bc
		pop	hl
		ld	sp,(Z80START+8)
;trochu naroste zasobnik, ale
;to by nemelo vadit
		push	de
		ld	de,(Z80START+13)
		jp	SNARUN
;konec prace se .z80
	endif	;WITH_Z80

	ifdef ANY_SNAP
;vsechny obsluhy snapu zacinaji stejne
SNAPINIT	di
		rst	40
		defw	SCRINIT2
		rst	24				;call PRINTSP
		defb	22,12,4,16,6,19,1
		defb	" Loading... Please wait "
		defb	19,128
;konfig 128 na 48 (reset stav)
		ld	a,16+64
		out	(253),a
;v ix adresa cele polozky
SNAPINIT2	push	ix
		pop	hl
;v hl adresa polozky
		ld	de,7
		add	hl,de
		rst	40
		defw	CAINIT
		pop	de
;potrebujem hodnotu puvodniho zasobniku pro pripad, kdyz se budem chtit vratit
;pro 128k snap v 48k modu
		ld	hl,0
		add	hl,sp
		ld	sp,LOADSTACK
		push	hl
		ex	de,hl
;na zasobnik si ulozime SNAERR (chyba ve snapu)
		ld	de,SNAERR
		push	de
		jp	(hl)			;navrat odkud bylo volano

;nacte cast souboru do VRAM a zkopiruje ji na spravne misto v druhe strance RAM
SNAPHEAD	ld	hl,SNATMP
;pokud chceme pouzit vlastni adresu (spousteni Z80)
SNAPHEAD2	push	de
		push	bc
		ex	de,hl
		push	de
		rst	40
		defw	CAREAD
		pop	hl
		pop	bc
		pop	de
		ret	c
		ld	a,BACKPAGE
		out	(RAMPORT),a	;potrebujem HL
		ldir
		xor	a			;NC a pro out
		rst	48			;ted uz ne :)
		ret

;prestrankuje pamet pro spousteni snapu, nastavi zasobnik a pocka na preruseni
INTSYNC	pop	de
		ld	a,BACKPAGE
		rst	48
		ld	sp,BACKSTACK
		ei
		halt
		di
		ex	de,hl
		jp	(hl)

;test pro 128k snapy, nesmeji jit pustit v 48k modu, pokud se tak stane,
;nasleduje hlaska a po stisku klavesy navrat do browseru
IS48KMODE	ld	a,(ACTPAGE)
		rla				;bit 7,a
		ret	nc
;je 48K mod, vyzvedni puvodni stack atd.
		pop	hl			;adresa volani
		pop	hl			;snaerr
		pop	hl			;puvodni zasobnik
		ld	sp,hl
		rst	24
		defb	22,12,0,17,0,16,2,18,1,19,1
		defb	"Can't load 128K snap in 48K mode"
		defb	19,0,18,128
;		ei
		rst	40
		defw	INKEYS		;cekme na klavesu
		jp	NEXTPG

	endif


;prepis souboru
OVRWRT	ld	a,(TAPACT)	;pro tapku ne
		or	a
		jr	nz,NOVRWRT
		call	GETFILE
		bit	1,(ix+25)
		jr	nz,NOVRWRT	;pro adresar ne
	ifdef WITH_SCR
;detekce obrazku
		ld	a,(ix+12)
		or	(ix+13)
		jr	nz,NOVRSCR
		ex	de,hl
		ld	l,(ix+10)
		ld	h,(ix+11)
;obrazek bez atributu?
		ld	bc,6144
		or	a
		sbc	hl,bc
		add	hl,bc
		jr	z,OVRSCR
;obrazek s atributy?
		ld	b,6912/256	;c=0
		or	a
		sbc	hl,bc
		jr	nz,NOVRSCRE
;zapisem jako barevny/monochromaticky obrazek (delka v BC)
OVRSCR	push	bc
		push	de
		rst	40
		defw	POPSCR
		pop	de
		ld	hl,7			;posun na lba v polozce
		add	hl,de
		rst	40
		defw	CAINIT
		pop	bc
		ld	de,16384
		rst	40
		defw	CAWRITE
;FIXME! osetreni chyby pri zapisusu
		rst	40
		defw	CAFLUSH
		xor	a
		out	(254),a
		jp	NEXTPG

NOVRSCRE	ex	de,hl
	endif ;WITH_SCR

NOVRSCR


NOVRWRT	rst	24
		defb	22,23,0,17,0,16,2,18,1,19,1
		defb	"Unknown or unsupported file type"
		defb	19,0,18,128
		rst	40
		defw	INKEYS		;wait for key
		jp	NEXTPG



;nakresli kurzor (browser)
KURZOR	ld	a,(KURCOL)
KURZORC	ex	af,af'
		ld	a,(POZICE)
KURZORA	push	hl
		push	de
;atrib kopie
		ld	hl,22528
		ld	de,22529		;rychlejsi
		ld	bc,767
		ld	(hl),7
		ldir
;az sem
		add	a,a
		add	a,a
		add	a,a
		ld	l,a
		ld	h,0
		add	hl,hl
		add	hl,hl
		ld	bc,22528
		add	hl,bc
		ex	af,af'
		ld	b,32
KURZOR2	ld	(hl),a
		inc	l			;v jednom radku
		djnz	KURZOR2
		pop	de
		pop	hl
		ret


;test pripony (3 znaky)
;v DE ukazatel na text pripony
;Z-je to ona
TESTPRIP	push	hl
		ex	de,hl
		ld	b,3
		call	STRNICMP
		pop	hl
		ret

;porovna 2 retezce (DE a HL) v delce B bytu
;znaky z DE jsou prevedeny na mala pismena
;navrat Z-rovnaji se
;C-(HL) je "vetsi" nez (DE)
STRNICMP	ld	a,(de)
		or	32
		cp	(hl)
		ret	nz
		inc	hl
		inc	de
		djnz	STRNICMP
		ret

BUFFCMP	ld	de,INPBUFF
NAMECMP	ld	a,c
		ld	bc,32
		add	hl,bc
;porovnani delek, kdyz je jmeno kratsi, nema cenu dal hledat
		cp	(hl)
		ret	nc
		inc	a			;delka v bufferu je o 1 mensi
		ld	b,a
		inc	hl
;		jr	STRNCMP
;sem nic nepridavat

;porovna 2 retezce (DE a HL) v delce B bytu
;navrat Z-rovnaji se
;C-(HL) je "vetsi" nez (DE)
STRNCMP	ld	a,(de)
		cp	(hl)
		ret	nz
		inc	hl
		inc	de
		djnz	STRNCMP
		ret


EXTTAP	defb	"tap"
EXTTZX	defb	"tzx"
	ifdef WITH_SNA
EXTSNA	defb	"sna"
	endif
	ifdef WITH_Z80
EXTZ80	defb	"z80"
	endif
	ifdef WITH_MFC
EXTMFC	defb	"mfc"
	endif
	ifdef WITH_POK
EXTPOK	defb	"pok"
	endif
;	ifdef WITH_TXT
;EXTTXT	defb	"txt"
;	endif
;	ifdef WITH_TRD
;EXTTRD	defb	"trd"
;	endif

;kody klaves browseru menu spolecne s obsluznymi programy
BRPROG	defb	'7'
		defw	UP
		defb	11
		defw	UP
		defb	'6'
		defw	DOWN
		defb	10
		defw	DOWN
		defb	'5'
		defw	PGUP
		defb	8
		defw	PGUP
		defb	'8'
		defw	PGDW
		defb	9
		defw	PGDW
		defb	13
		defw	ENTER
		defb	14
		defw	RET2MAIN
		defb	15
		defw	OVRWRT
		defb	16
		defw	NEXTPG		;"sezrani" SS+E
		defb	' '
		defw	RET2MAIN
		defb	0


TZXMAGIC	defb	"ZXTape!",$1A

;tabulka delek pro jednotlive .TZX bloky
;pouze pro hodnoty 0-127!
;0. pocet bajtu "hlavicky"
;1. spodni 4 bity pocet bajtu delky
;+128 - nasobit dvema (pricist 1x)
;+64 - nasobit tremi (pricist 1x, tj. musi byt i +128)
;+32 - pritomnost bloku nejspis zpusobi nefunkcnost tzx
;2. startovni byte delky (i pro 1.=0!)
TZXLENS
;nezname jako "extension rules"
		defb	16 dup (4,4,0)
;ID $10 - Standard Speed Data Block
		defb	4,2,2
;ID $11 - Turbo Loading Data Block
		defb	$12,3+32,$F
;ID $12 - Pure Tone
		defb	4,0+32,0
;ID $13 - Sequence of Pulses of Different Lengths
		defb	1,1+128+32,0
;ID $14 - Pure Data Block
		defb	$A,3+32,7
;ID $15 - Direct Recording
		defb	8,3+32,5
;ID $16 - C64 ROM Type Data Block
		defb	4,4,0
;ID $17 - C64 Turbo Tape Data Block
		defb	4,4,0
		defb	8 dup (4,4,0)
;ID $20 - Pause (Silence) or 'Stop the Tape' Command
		defb	2,0,0
;ID $21 - Group Start
		defb	1,1+32,0
;ID $22 - Group End
		defb	0,0+32,0
;ID $23 - Jump To Block
		defb	2,0+32,0
;ID $24 - Loop Start
		defb	2,0+32,0
;ID $25 - Loop End
		defb	0,0+32,0
;ID $26 - Call Sequence
		defb	2,2+128+32,0
;ID $27 - Return From Sequence
		defb	0,0+32,0
;ID $28 - Select Block
		defb	2,2+32,0
		defb	1 dup (4,4,0)
;ID $2A - Stop Tape if in 48K Mode
		defb	4,4,0
		defb	5 dup (4,4,0)
;ID $30 - Text Description
		defb	1,1,0
;ID $31 - Message Block
		defb	2,1,1
;ID $32 - Archive Info
		defb	2,2,0
;ID $33 - Hardware Type
		defb	1,1+128+64,0
;ID $34 - Emulation Info
		defb	8,0,0
;ID $35 - Custom Info Block
		defb	$14,4,$10
		defb	10 dup (4,4,0)
;ID $40 - Snapshot Block
		defb	4,3+32,1
		defb	25 dup (4,4,0)
;ID $5A - (90 dec, ASCII Letter 'Z')
		defb	9,0,0
		defb	36 dup (4,4,0)

	ifdef WITH_MTF
;popisy TZX bloku

TZXTID00	defb	"Unknown bloc",'k'+128
;TZXTID10	defb	"Standard Speed Data Bloc",'k'+128
TZXTID11	defb	"Turbo Loading Data Bloc",'k'+128
TZXTID12	defb	"Pure Ton",'e'+128
TZXTID13	defb	"Sequence of Pulse",'s'+128
TZXTID14	defb	"Pure Data Bloc",'k'+128
TZXTID15	defb	"Direct Recordin",'g'+128
TZXTID16	defb	"C64 ROM Type Data Bloc",'k'+128
TZXTID17	defb	"C64 Turbo Tape Data Bloc",'k'+128
TZXTID20	defb	"Pause or 'Stop the Tape",39+128
TZXTID21	defb	"Group Star",'t'+128
TZXTID22	defb	"Group En",'d'+128
TZXTID23	defb	"Jump To Bloc",'k'+128
TZXTID24	defb	"Loop Star",'t'+128
TZXTID25	defb	"Loop En",'d'+128
TZXTID26	defb	"Call Sequenc",'e'+128
TZXTID27	defb	"Return From Sequenc",'e'+128
TZXTID28	defb	"Select Bloc",'k'+128
TZXTID2A	defb	"Stop Tape if in 48K Mod",'e'+128
TZXTID30	defb	"Text Descriptio",'n'+128
TZXTID31	defb	"Message Bloc",'k'+128
TZXTID32	defb	"Archive Inf",'o'+128
TZXTID33	defb	"Hardware Typ",'e'+128
TZXTID34	defb	"Emulation Inf",'o'+128
TZXTID35	defb	"Custom Info Bloc",'k'+128
TZXTID40	defb	"Snapshot Bloc",'k'+128
TZXTID5A	defb	"'Join Marker",39+128

;tabulka textu TZX bloku
TZXTEXTS	defw	16 dup (TZXTID00)
		defw	TZXTID00				;std.blok se rovnou pouzije 
		defw	TZXTID11
		defw	TZXTID12
		defw	TZXTID13
		defw	TZXTID14
		defw	TZXTID15
		defw	TZXTID16
		defw	TZXTID17
		defw	8 dup (TZXTID00)
		defw	TZXTID20
		defw	TZXTID21
		defw	TZXTID22
		defw	TZXTID23
		defw	TZXTID24
		defw	TZXTID25
		defw	TZXTID26
		defw	TZXTID27
		defw	TZXTID28
		defw	1 dup (TZXTID00)
		defw	TZXTID2A
		defw	5 dup (TZXTID00)
		defw	TZXTID30
		defw	TZXTID31
		defw	TZXTID32
		defw	TZXTID33
		defw	TZXTID34
		defw	TZXTID35
		defw	10 dup (TZXTID00)
		defw	TZXTID40
		defw	25 dup (TZXTID00)
		defw	TZXTID5A
		defw	36 dup (TZXTID00)

	endif ;WITH_MTF

ROMEND1

;strankovani zpet do ROM ZXS
		org	8192+$1FF0
		phase $1FF0
ROMSRAM	ld	a,BACKPAGE
		out	(RAMPORT),a		;potebujem zachovat HL
		jr	TOBASROM
;shodne s CONROM, navesti odtamtud
		pop	af				;EIROM2
		ei					;EIROM
;o strankovani se stara HW
		ret					;TOBASROM
		jp	(hl)				;ROMJPHL

;identifikace druhe casti (5B)
PAGESIGN	defb	DVERS


FREEROM0	equ	LOGO-ROMEND0
FREEROM1	equ	8192-ROMEND1

	if FREEROM0 < 0
		error "\aNo free ROM0 left!"
	endif
	
	if FREEROM1 < 0
		error "\aNo free ROM1 left!"
	endif

	if FREERAM0 < 0
		error "\aNo free RAM0 left!"
	endif

	if FREERAM1 < 0
		error "\aNo free RAM1 left!"
	endif

;	if FREERAM2 < 0
;		error "\aNo free RAM2 left!"
;	endif

	if OVRLENDE <> OVRLENDR
		error "\aOverlays not match!"
	endif

	ifdef NEVER

;1.1 Classic 8-bit * 8-bit Unsigned
;Input: H = Multiplier, E = Multiplicand, L = 0, D = 0
;Output: HL = Product

	sla	h		; optimised 1st iteration
	jr	nc,$+3
	ld	l,e

	add	hl,hl		; unroll 7 times
	jr	nc,$+3		; ...
	add	hl,de		; ...

;1.2 Classic 16-bit * 8-bit Unsigned
;Input: A = Multiplier, DE = Multiplicand, HL = 0, C = 0
;Output: A:HL = Product

	add	a,a		; optimised 1st iteration
	jr	nc,$+4
	ld	h,d
	ld	l,e

	add	hl,hl		; unroll 7 times
	rla			; ...
	jr	nc,$+4		; ...
	add	hl,de		; ...
	adc	a,c		; ...

;1.3 Classic 16-bit * 16-bit Unsigned
;Input: DE = Multiplier, BC = Multiplicand, HL = 0
;Output: DE:HL = Product

	sla	e		; optimised 1st iteration
	rl	d
	jr	nc,$+4
	ld	h,b
	ld	l,c

	add	hl,hl		; unroll 15 times
	rl	e		; ...
	rl	d		; ...
	jr	nc,$+6		; ...
	add	hl,bc		; ...
	jr	nc,$+3		; ...
	inc	de		; ...



;2.1 Classic 8-bit / 8-bit Unsigned
;Input: D = Dividend, E = Divisor, A = 0
;Output: D = Quotient, A = Remainder

	sla	d		; unroll 8 times
	rla			; ...
	cp	e		; ...
	jr	c,$+4		; ...
	sub	e		; ...
	inc	d		; ...


;Input: D = Dividend, E = Divisor, A = 0, Carry = 0
;Output: A = Quotient, E = Remainder

	rl	d		; unroll 8 times
	rla			; ...
	sub	e		; ...
	jr	nc,$+3		; ...
	add	a,e		; ...


	ld	e,a		; save remainder
	ld	a,d		; complement the result
	cpl


;2.2 Classic 16-bit / 8-bit Unsigned
;Input: HL = Dividend, C = Divisor, A = 0
;Output: HL = Quotient, A = Remainder (see note)

	add	hl,hl		; unroll 16 times
	rla			; ...
	cp	c		; ...
	jr	c,$+4		; ...
	sub	c		; ...
	inc	l		; ...

;2.3 Classic 16-bit / 16-bit Unsigned
;Input: A:C = Dividend, DE = Divisor, HL = 0
;Output: A:C = Quotient, HL = Remainder

	slia	c		; unroll 16 times
	rla			; ...
	adc	hl,hl		; ...
	sbc	hl,de		; ...
	jr	nc,$+4		; ...
	add	hl,de		; ...
	dec	c		; ...

;2.4 Classic 24-bit / 8-bit Unsigned
;Input: E:HL = Dividend, D = Divisor, A = 0
;Output: E:HL = Quotient, A = Remainder

	add	hl,hl		; unroll 24 times
	rl	e		; ...
	rla			; ...
	cp	d		; ...
	jr	c,$+4		; ...
	sub	d		; ...
	inc	l		; ...

;2.5 Classic 24-bit / 16-bit Unsigned
;Input: A:BC = Dividend, DE = Divisor, HL = 0
;Output: A:BC = Quotient, HL = Remainder

	slia	c		; unroll 24 times
	rl	b		; ...
	rla			; ...
	adc	hl,hl		; ...
	sbc	hl,de		; ...
	jr	nc,$+4		; ...
	add	hl,de		; ...
	dec	c		; ...

;2.6 Classic 32-bit / 8-bit Unsigned
;Input: DE:HL = Dividend, C = Divisor, A = 0
;Output: DE:HL = Quotient, A = Remainder

	add	hl,hl		; unroll 32 times
	rl	e		; ...
	rl	d		; ...
	rla			; ...
	cp	c		; ...
	jr	c,$+4		; ...
	sub	c		; ...
	inc	l		; ...

	endif


; nastaveni pro VI (tabulatory 5 znaku a filetype)
; vim:set ts=5 ft=z8asl:
